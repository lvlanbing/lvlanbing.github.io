{"meta":{"title":"吕兰兵的博客","subtitle":"","description":"","author":"吕兰兵","url":"https://lvlanbing.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-04-25T06:26:00.000Z","updated":"2022-04-25T12:30:16.399Z","comments":false,"path":"about/index.html","permalink":"https://lvlanbing.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"TCP连接的建立和断开","slug":"TCP连接的建立和断开","date":"2022-05-13T01:18:25.000Z","updated":"2022-05-13T07:06:05.782Z","comments":true,"path":"2022/05/13/TCP连接的建立和断开/","link":"","permalink":"https://lvlanbing.github.io/2022/05/13/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%96%AD%E5%BC%80/","excerpt":"","text":"TCP连接的建立和断开预备知识TCP是向应用层提供可靠的传输服务。TCP的下层服务是IP层，而IP层提供的是不可靠的服务。同时TCP的服务是点到点的（port到port），IP是端到端的（主机到主机）。TCP头部的一些字段要知道。 12345源端口号，目的端口号序号确认号连接建立和断开的字段（SYN，FIN，RST）接收窗口 序号：开始随机产生一个数（防止有相同的序号），之后下一个序号 = 上一个序号 + 上一个数据的长度。应用层交付的数据可能大于MSS的，所以需要对数据进行分片。确认号：确认数据报是否成功接受到，确认号 = 收到的序号 + 1 连接建立怎样才算连接建立？像UDP，客户端知道目的端的IP和端口，就可以把数据发送的目的端。TCP同样是发送数据，但是需要建立连接后才能发送数据。TCP是为了向上层提供有序，无差错的数据，所以需要建立连接。连接建立就像初始化一样。我们有了固定的规则，但是变量没有值。（比如序号，接收窗口等）这样客户端要告诉服务端，客户端的情况；服务端要告诉客户端的情况。从这个角度来说，我们两次的握手就可以建立连接了。为什么连接建立都是三次握手呢？我们先来看看两次握手为什么不行。网络是不稳定的，会出现高延迟，数据报的丢失。客户端在时间t1向服务端发送连接建立请求。客户端在时间t3才接收到服务器的应答。(t1, t3)这个时间段已经超过t1时间的设置的超时时钟，导致客户端在时间t2再次向服务端发送请求。上述情况中多了连接的建立次，这会导致服务端压力增大。服务端对t1时刻数据报的应答，客户端在（t2，t3）之间接收到。那么客户端有两个连接，就需要发送两个相同的数据报。这样效率低下。这就需要三次握手解决半连接和接收老数据问题 当客户端三次握手建立好连接后。中间可以能会出现，客户端再次请求连接。但是服务端应答的确认号A是之前使用过的了。客户端在最后一次的握手，所期待的确认号不是A，所以这次连接会被拒绝掉。这样可以解决客户端发送重复的数据报（在没有超时的情况下）。序号，客户端和服务端都会自己随机一个初始值。 连接断开TCP是全双工的，两个方向都要断开。客户端和服务端都可以发起断开请求，但是大多数都是客户端发起断开请求。1、客户端到服务端方向的连接断开。这时服务端向客户端发送数据，客户端还是能收到。现在处于半关闭状态。2、服务端到客户端方向的连接断开但是还没有正真的断开连接，因为客户端需要等待2*max segment lifetime（报文段最大生存时间）之后才会关闭连接。 TIME_WAIT状态TIME_WAIT状态存在的原因：1、可靠地终止TCP连接2、保证让迟来的TCP报文段有足够的时间识别并丢弃当客户端对服务器断开连接的请求的应答报文丢失。如果客户端已接受到服务端的断开请求，客户端就认为连接断开了。那么对于之后服务端的重复发送，不再做任何的应答，这样的断开连接是失败的。所以在接受到服务端的断开请求后，客户端还有维持2*max segment lifetime时间之后才会关闭服务。在这段时间里，能最大限度的保证连接的断开。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://lvlanbing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://lvlanbing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"cs144_lab0","slug":"cs144-lab0","date":"2022-05-10T14:10:53.000Z","updated":"2022-05-10T14:28:59.294Z","comments":true,"path":"2022/05/10/cs144-lab0/","link":"","permalink":"https://lvlanbing.github.io/2022/05/10/cs144-lab0/","excerpt":"","text":"准备工作Writing webget1234567891011121314151617181920212223void get_URL(const string &amp;host, const string &amp;path) &#123; // You will need to connect to the &quot;http&quot; service on // the computer whose name is in the &quot;host&quot; string, // then request the URL path given in the &quot;path&quot; string. // Then you&#x27;ll need to print out everything the server sends back, // (not just one call to read() -- everything) until you reach // the &quot;eof&quot; (end of file). TCPSocket ss; ss.connect(Address(host, &quot;http&quot;)); // 模拟http请求头部 string str = &quot;GET &quot;+ path + &quot; HTTP/1.1\\r\\nHost: &quot; + host + &quot;\\r\\nConnection: close\\r\\n\\r\\n&quot;; string recv_str; // 向服务器发送 ss.write(str); // eof保证接受完 while(ss.eof() == false) &#123; ss.read(recv_str); cout&lt;&lt;recv_str; &#125; ss.close();&#125; An in-memory reliable byte stream数据结构12345std::string _buffer = &quot;&quot;; //缓存区size_t _capacity = 0;bool _input_ended_flag = false;size_t _write_count = 0;size_t _read_count = 0; 功能实现write12345678910size_t ByteStream::write(const string &amp;data) &#123; size_t len = data.length(); if(len &gt; _capacity - _buffer.length()) &#123; len = _capacity - _buffer.length(); &#125; _write_count = _write_count + len; std::string msg = data.substr(0, len); _buffer += msg; return len;&#125; peek_output12345678string ByteStream::peek_output(const size_t len) const &#123; size_t lenght = len; std::string msg; if(len &gt; _buffer.size()) lenght = _buffer.size(); msg = _buffer.substr(0, lenght); return msg;&#125; pop_output1234567void ByteStream::pop_output(const size_t len) &#123; size_t lenght = len; if(len &gt; _buffer.size()) lenght = _buffer.size(); _read_count += lenght; _buffer.erase(0, lenght);&#125; read12345std::string ByteStream::read(const size_t len) &#123; string s = peek_output(len); pop_output(len); return s;&#125; 其他123456789101112131415void ByteStream::end_input() &#123;_input_ended_flag = true;&#125;bool ByteStream::input_ended() const &#123; return _input_ended_flag; &#125;size_t ByteStream::buffer_size() const &#123; return _buffer.size(); &#125;bool ByteStream::buffer_empty() const &#123; return _buffer.length() == 0; &#125;bool ByteStream::eof() const &#123; return buffer_empty() &amp;&amp; input_ended(); &#125;size_t ByteStream::bytes_written() const &#123; return _write_count; &#125;size_t ByteStream::bytes_read() const &#123; return _read_count; &#125;size_t ByteStream::remaining_capacity() const &#123; return _capacity - _buffer.size(); &#125; 问题当程序逻辑完全正确的情况。执行make check_lab0, 可能会出现以下问题 12345678910111213141516171819202122232425262728[100%] Testing Lab 0...Test project /home/ubuntu/CS144_2021/lab0/sponge/build Start 26: t_byte_stream_construction1/9 Test #26: t_byte_stream_construction .......***Failed 0.00 secTest Failure on expectation: Expectation: buffer_empty: 1Failure message: The ByteStream should have had buffer_empty equal to 1 but instead it was 0List of steps that executed successfully: Initialized with (capacity=15) Expectation: input_ended: 0Exception: The test &quot;construction&quot; failed.........5/9 Test #30: t_byte_stream_many_writes ........***Failed 0.00 secTest Failure on expectation: Action: write &quot;xrvebsengdwiqtkslspvlftaqaadlafzowwevyeqmyokuxdmgnbfjiilhczumsxolkvdcpficcgnigauadmpnlgalffifjhgnzydbzrjtcpwsmhujsbjzcptbifgiynnodjbbbjnpwrmffcctvcwx&quot; to the streamFailure message: The ByteStream should have had bytes_written equal to 149 but instead it was 0List of steps that executed successfully: Initialized with (capacity=200000)Exception: The test &quot;many writes&quot; failed..... 这时需要重新对整个项目make一下，之后再执行make check_lab0","categories":[{"name":"CS144","slug":"CS144","permalink":"https://lvlanbing.github.io/categories/CS144/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://lvlanbing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://lvlanbing.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"CS144_notes","slug":"CS144-notes","date":"2022-05-09T08:24:55.000Z","updated":"2022-05-09T08:30:24.672Z","comments":true,"path":"2022/05/09/CS144-notes/","link":"","permalink":"https://lvlanbing.github.io/2022/05/09/CS144-notes/","excerpt":"","text":"准备工作12345678910111213141516171819202122To run the labs, you’ll need the following software:g++ version 8.xclang-tidy version 6 or 7clang-format version 6 or 7cmake version 3 or laterlibpcap development headers (libpcap-dev on Debian-like distributions)gitiptablesmininet 2.2.0 or latertcpdumptelnetwiresharksocatnetcat-openbsdGNU coreutilsbashdoxygengraphvizNote: there are at least three versions of netcat. You won’t be using it much, but when you do, we will assume you’ve got the OpenBSD variant. Others might also work, though it is possible that they will require different commandline flags.We’ve tested the labs with recent Debian-derived systems (Ubuntu 18.04 and similar) and Arch Linux. In all likelihood, other modern Linux distributions will also work. 问题1：g++ -v or gcc -v的版本是小于8，就会导致cmake的时候失败解决： 1234567sudo apt-get updatesudo apt-get install gcc-8sudo apt-get install g++-8cd /usr/binsudo rm gcc g++sudo ln -s gcc-8 gccsudo ln -s g++-8 g++","categories":[{"name":"CS144","slug":"CS144","permalink":"https://lvlanbing.github.io/categories/CS144/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://lvlanbing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"线程切换","slug":"线程切换","date":"2021-11-29T13:28:32.000Z","updated":"2021-11-29T13:31:49.062Z","comments":true,"path":"2021/11/29/线程切换/","link":"","permalink":"https://lvlanbing.github.io/2021/11/29/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/","excerpt":"进程：指令执行序列+资源。进程的切换除了PC指针（程序计数器，存放下一条指令地址）的变化，映射表（资源）也要发生变化。 线程：一个进程中有多个线程，它们共用该进程中的资源。所以线程的切换不需要对资源进行切换。线程的切换的速度就要比进程的切换要快很多。","text":"进程：指令执行序列+资源。进程的切换除了PC指针（程序计数器，存放下一条指令地址）的变化，映射表（资源）也要发生变化。 线程：一个进程中有多个线程，它们共用该进程中的资源。所以线程的切换不需要对资源进行切换。线程的切换的速度就要比进程的切换要快很多。 先说线程的切换 线程A在切换到线程C的时候需要保存线程A之前运行的结果和之后又要重那里接着运行的地址。 这里我们使用栈来保存 上图是两个线程使用一个栈，其中数字对应着地址。Yeild函数指定切换到那里。在用户态可以自己编写切换程序，但是在内核中只能使用内核的切换算法了。 想一想这样做能成功的从2准确的回到3并正常运行？ 当回到(3)处，遇到“}”时要出栈。出栈的第一个地址为404，现在有回到另一个线程。然后执行404后的代码再遇到”}”时有出栈，地址为304。这就切换失败了，但是能切换。 如果每个线程都有自己的栈会不会更好一点。这就出现每个线程都有自己的线程控制块（TCB）。每个栈都与TCB进行关联。当前栈的栈顶地址是存放在CPU里面的esp寄存器里面的， 因此只需要改变esp的值就可以切换栈了 123456void Yield()&#123; TCB2.esp = esp; // 保存当前栈顶地址 esp = TCB1.esp; // 切换栈 jmp 204; &#125; 现在(3)后遇到“}”后根据栈出了的地址为204。我们想要的是回到104地址了，还是失败了，但是并没有在另一个线程中了。 解决： 就是把Yield中的 jmp 204 地址去到。也就是在Yield中的函数中“}”时就把204地址弹出了，再遇到B()中的”}”时弹出来的就是104地址了。 现在就线程切换的思路了。 目前只是用户态下的切换，并没有涉及到内核态。 问题：用户态线程内核是不知道的，当用户态中的一个线程要去访问磁盘资源，内核不知道，就让该进程继续使用CPU资源，但是它并没有在使用CPU。这就造成了资源的浪费。 用户态一个进程有多个线程，当一个线程阻塞了。内核是看不到用户的线程，则就把进程切换了。导致进程中的线程无法切换了。 多核处理器用的是同一个MMU（Memory Management Unit），这就是多线程模式。则内核级线程技术，能更好的发挥硬件的优势。 用户级线程与内核级线程： 用户级线程在发生中断才能进入到内核级线程 内核级线程是要在内核中执行的程序。则内核级线程需要在用户态和核心态里跑，用户态有一个用户栈，核心态中有一个核心栈。用户栈和核心栈称为一套栈。 同又出现了一个新的问题就是：用户态的线程怎么和内核态下的线程协同合作呢？ 用户栈与内核栈之间的关联。 一个栈到一套栈；两个栈到两套栈。用户态下的栈与内核态下的栈关联起来。 中断时，线程进入到内核中，OS根据硬件的寄存器来知道这个线程，它对应的内核栈在那里。同时回将用户态的栈的位置（SS，SP）和程序执行到那里的位置（CS(Code Segment)，IP(Instruction Pointer)）都压入内核栈中保存下来。 线程在内核中执行完，退出内核态回到用户态时（也就是iret指令），就根据之前的内核栈中存入的SS和SP的值来找用户栈，根据CS和PC值找程序接下来该执行的位置。 例子： 在内核中线程的切换是通过switch_to()函数实现的，就是从当前线程的内核栈切换到next线程的内核栈。 内核级线程的代码还是在用户态的，只是进入内核态完成系统调用，就是逛一圈之后还是要回去执行的。 线程S切换到线程T要根据线程T的内核栈找到这个线程阻塞的位置，执行线程T的函数。线程T的内核栈之后，通过iret指令从内核栈返回到用户态执行线程T的代码。 内核级线程的切换五个步骤： 中断进入内核 在内核态中，由于启动磁盘或者时钟中断，引发线程切换 通过TCB对内核栈进行切换 使用iret推出中断，对用户栈进行切换。内核栈和用户栈都完成了切换 如果线程不是同一个进程，还需要对内存映射表进行切换 实验：基于内核栈切换的进程切换环境：linux0.11 Linux0.11完成进程切换是依靠任务状态段（task state segment, TSS)的切换来完成的。 现在我们要舍弃TSS，重新写一个切换程序。 关于TSS具体的过程参考该链接 有一个任务寄存器（Task Register，简称 TR）指向当前进程对应的 TSS 结构体，所谓的 TSS 切换就将 CPU 中几乎所有的寄存器都复制到 TR 指向的那个 TSS 结构体中保存起来，同时找到一个目标 TSS，即要切换到的下一个进程对应的 TSS，将其中存放的寄存器映像“扣在” CPU 上，就完成了执行现场的切换。 虽然用一条指令就能完成任务切换，但这指令的执行时间却很长，这条 ljmp 指令在实现任务切换时大概需要 200 多个时钟周期（TSS）。而通过堆栈实现任务切换可能要更快，而且采用堆栈的切换还可以使用指令流水的并行优化技术，同时又使得 CPU 的设计变得简单 进程的切换：PCB和内存映射表都要切换 原始的切换位置的程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * &#x27;schedule()&#x27;是调度函数。这是个很好的代码！没有任何理由对它进行修改，因为它可以在所有的 * 环境下工作（比如能够对IO-边界处理很好的响应等）。只有一件事值得留意，那就是这里的信号 * 处理代码。 * 注意！！任务0 是个闲置(&#x27;idle&#x27;)任务，只有当没有其它任务可以运行时才调用它。它不能被杀 * 死，也不能睡眠。任务0 中的状态信息&#x27;state&#x27;是从来不用的。 */void schedule (void)&#123; int i, next, c; struct task_struct **p; // 任务结构指针的指针。/* 检测alarm（进程的报警定时值），唤醒任何已得到信号的可中断任务 */// 从任务数组中最后一个任务开始检测alarm。 for (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p) if (*p) &#123;// 如果任务的alarm 时间已经过期(alarm&lt;jiffies),则在信号位图中置SIGALRM 信号，然后清alarm。// jiffies 是系统从开机开始算起的滴答数（10ms/滴答）。定义在sched.h 第139 行。 if ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123; (*p)-&gt;signal |= (1 &lt;&lt; (SIGALRM - 1)); (*p)-&gt;alarm = 0; &#125;// 如果信号位图中除被阻塞的信号外还有其它信号，并且任务处于可中断状态，则置任务为就绪状态。// 其中&#x27;~(_BLOCKABLE &amp; (*p)-&gt;blocked)&#x27;用于忽略被阻塞的信号，但SIGKILL 和SIGSTOP 不能被阻塞。 if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp; (*p)-&gt;state == TASK_INTERRUPTIBLE) (*p)-&gt;state = TASK_RUNNING; //置为就绪（可执行）状态。 &#125; /* 这里是调度程序的主要部分 */ while (1) &#123; c = -1; next = 0; i = NR_TASKS; p = &amp;task[NR_TASKS];// 这段代码也是从任务数组的最后一个任务开始循环处理，并跳过不含任务的数组槽。比较每个就绪// 状态任务的counter（任务运行时间的递减滴答计数）值，哪一个值大，运行时间还不长，next 就// 指向哪个的任务号。 while (--i) &#123; if (!*--p) continue; if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i; &#125; // 如果比较得出有counter 值大于0 的结果，则退出124 行开始的循环，执行任务切换（141 行）。 if (c) break; // 否则就根据每个任务的优先权值，更新每一个任务的counter 值，然后回到125 行重新比较。 // counter 值的计算方式为counter = counter /2 + priority。[右边counter=0??] for (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p) if (*p) (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) + (*p)-&gt;priority; &#125; switch_to (next); // 切换到任务号为next 的任务，并运行之。&#125; switch_to()为切换函数 123456789101112131415//TSS切换函数如下#define switch_to(n) &#123;\\struct &#123;long a,b;&#125; __tmp; \\__asm__( &quot;cmpl %%ecx,_current\\n\\t&quot; \\ &quot;je 1f\\n\\t&quot; \\ &quot;movw %%dx,%1\\n\\t&quot; \\ &quot;xchgl %%ecx,_current\\n\\t&quot; \\ 。 &quot;ljmp %0\\n\\t&quot; \\ 。// 在任务切换回来后才会继续执行下面的语句。 &quot;cmpl %%ecx,_last_task_used_math\\n\\t&quot; \\ &quot;jne 1f\\n\\t&quot; \\ &quot;clts\\n&quot; \\ &quot;1:&quot;::&quot;m&quot; (*&amp;__tmp.a), &quot;m&quot; (*&amp;__tmp.b), &quot;d&quot; (_TSS (n)), &quot;c&quot; ((long) task[n]));&#125; 修改：我们需要一个指针指向我们要切换的地址，进程切换必然要涉及到 LDT 的切换。linux0.11是没有线程的。 每个进程对应有 1 个 TSS 和 1 个 LDT，LDT 就是个映射表 123456789//对应的修改为：if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) &#123; /* code */ c = (*p)-&gt;counter, next = i; pnext = *p; &#125;//当前的进程使用全局变量保存的，所以只需要下一个要切换的进程//pnext 是任务结构指针，也就是堆栈switch_to(pnext, _LDT(next)); 重新switch_to函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546.align 2 #对齐伪指令，必须从一个能被2整除的地址开始为下面的内存变量分配空间switch_to:#这一部分的解释，看上述内存模型: stack pushl %ebp movl %esp,%ebp pushl %ecx pushl %ebx pushl %eax movl 8(%ebp),%ebx # 调用switch_to的第一个参数，即pnext——目标进程的PCB cmpl %ebx, current #和 current 做一个比较, current指向当前进程的PCB je 1f #相等就啥也不用做，跳转到“1：”直接恢复保存的寄存器即可#不相等，开始进程切换#先切换PCB movl %ebx,%eax #eax指向目标进程的PCB xchgl %eax,current #current指向目标进程的PCB, eax指向当前进程的PCB#TSS中的内核指针的重写 movl tss,%ecx #ecx指向当前进程的TSS addl $4096,%ebx #ebx指向的是目标进程的PCB，+4096后指向目标进程的内核栈 movl %ebx,ESP0(%ecx) #TSS的esp0指向目标进程的内核栈#切换内核栈栈顶指针（切换当前的内核栈为目标内核栈）；当然要先保存被切换进程的esp movl %esp, KERNEL_STACK(%eax) #把当前进程的esp保存到其PCB中 movl 8(%ebp),%ebx #再一次把目标进程的PCB存储到ebx中 movl KERNEL_STACK(%ebx),%esp #把目标进程PCB中的内核栈基址存储到esp中#切换LDT movl 12(%ebp),%ecx #把_LDT(next)存储到ecx中 lldt %cx #修改LDTR寄存器后，目标进程在执行用户态程序时使用的映射表就是自己的LDT表，实现了地址空间的分离。#通过ret完成PC的切换#切换LDT之后，更新fs，指向目标进程的用户态内存 movl $0x17,%ecx #用户空间数据段选择符为0x17 mov %cx,%fs #和后面的clts配合来处理协处理器，由于和主题关系不大，此处不做论述 cmpl %eax, last_task_used_math jne 1f clts1: popl %eax popl %ebx popl %ecx popl %ebpret 由于现在的 Linux 0.11 的 PCB 定义中没有保存内核栈指针这个域，所以需要加上，而宏 KERNEL_STACK 就是你加的那个位置，当然将 kernelstack 域加在 task_struct。 在linux-0.11/include/linux/sched.h 123456789101112struct task_struct &#123;/* these are hardcoded - don&#x27;t touch */ long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ long counter; long priority; long kernelstack; long signal; struct sigaction sigaction[32]; . . .&#125; 修改了结构体，同时也要修改该结构体的初始化。位置要对应起来 12345678#define INIT_TASK \\/* state etc */ &#123; 0,15,15,PAGE_SIZE+(long)&amp;init_task, \\/* signals */ 0,&#123;&#123;&#125;,&#125;,0, \\/* ec,brk... */ 0,0,0,0,0,0, \\/* pid etc.. */ 0,-1,0,0,0, \\/* uid etc */ 0,0,0,0,0,0, \\/* alarm */ 0,0,0,0,0,0, \\/* math */ 0, \\ 修改fork 就是要把进程的用户栈、用户程序和其内核栈通过压在内核栈中的 SS:ESP，CS:IP 关联在一起。 在 fork() 的核心实现 copy_process 中，p = (struct task_struct *) get_free_page();用来完成申请一页内存(大小4k)作为子进程的 PCB 而 p 指针加上页面大小就是子进程的内核栈位置，所以语句 krnstack = (long *) (PAGE_SIZE + (long) p); 就可以找到子进程的内核栈位置 接下来就是初始化krnstack 12345*(--krnstack) = ss &amp; 0xffff;*(--krnstack) = esp;*(--krnstack) = eflags;*(--krnstack) = cs &amp; 0xffff;*(--krnstack) = eip; 完成了如下图的关联 由于 fork() 这个叉子的含义就是要让父子进程共用同一个代码、数据和堆栈，现在虽然是使用内核栈完成任务切换，但 fork() 的基本含义不会发生变化。 内核切换完事，到子进程的内核栈开始工作，接下来做的四次弹栈以及 ret 处理使用的都是子进程内核栈中的东西， 123451: popl %eax popl %ebx popl %ecx popl %ebpret 为了顺利的完成这些弹栈工作，子进程的内核栈中应该有这些内容，所以需要对 krnstack 进行初始化 12345*(--krnstack) = ebp;*(--krnstack) = ecx;*(--krnstack) = ebx;// 这里的 0 最有意思。*(--krnstack) = 0;//eax 现在到了 ret 指令了，这条指令要从内核栈中弹出一个 32 位数作为 EIP 跳去执行，所以需要弄一个函数地址（仍然是一段汇编程序，所以这个地址是这段汇编程序开始处的标号）并将其初始化到栈中 我们弄的一个名为 first_return_from_kernel 的汇编标号，然后可以用语句 (--krnstack) = (long) first_return_from_kernel; 将这个地址初始化到子进程的内核栈中，现在执行 ret 以后就会跳转到 first_return_from_kernel 去执行了。 first_return_from_kernel 完成用户栈和用户代码的切换。依靠的核心指令就是 iret，切换之前需要回复一下执行现场 first_return_from_kernel 的核心代码 12345678popl %edxpopl %edipopl %esipop %gspop %fspop %espop %dsiret 将存放在 PCB 中的内核栈指针修改到初始化完成时内核栈的栈顶 1p-&gt;kernelstack = krnstack; 问题 1234567891011//kernel/sched.c在schedule函数中//下面这段代码能正常编译，但是无法正常运行if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i; pnext = *p; //而这段代码这可以正常运行if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i, pnext=*p; /**///其实这两段代码都是相同，为什么有这种差异。//我重新写一遍又都正常了，奇怪。//就这个问题困扰了我很久还没有解决，只有重新写。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://lvlanbing.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"线程","slug":"线程","permalink":"https://lvlanbing.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"DNS","slug":"DNS","date":"2021-11-24T08:33:05.000Z","updated":"2021-11-24T08:34:43.890Z","comments":true,"path":"2021/11/24/DNS/","link":"","permalink":"https://lvlanbing.github.io/2021/11/24/DNS/","excerpt":"在浏览器中往往输入的是服务器的域名，很少输入IP地址来访问域名。 IP地址人们往往很难记忆，对名称的记忆更容易。 这就存在域名与IP地址的映射了。 域名转化成IP地址的过程需要DNS服务器进行解析。 而在编码是常用gethostbyname()函数来解析","text":"在浏览器中往往输入的是服务器的域名，很少输入IP地址来访问域名。 IP地址人们往往很难记忆，对名称的记忆更容易。 这就存在域名与IP地址的映射了。 域名转化成IP地址的过程需要DNS服务器进行解析。 而在编码是常用gethostbyname()函数来解析 我们的计算机上有DNS客户端向DNS服务器发送服务请求 生成查询消息 向DNS服务器发送查询消息 交给UDP来传输到目标服务器 DNS服务器根据查询消息返回响应消息 DNS使用的是53端口 假设离主机最近的DNS服务器，主机查询的名字在该区域内部和在缓存中，那么本地DNS服务器就直接返回信息 DNS服务器有缓存功能，可以记住之前查询过的域名。一般存活时间为2天 一台DNS服务器不可能包含所有的信息。 一台DNS服务器可以管理多个域的信息 DNS服务器中的所有信息都是按照域名以分层次的结构来保存的。顶级域(TLD)服务器 一个域名为www.example.com。该域名下可以分配子域，比如www.sub1.example.com; www.sub2.example.com.但是需要www.example.com域同意。 当本地DNS服务器中没有时，就需要向根DNS服务器进行查询。查询方式有两种。 递归查询：向根服务器查询，让根服务器找到后在返回域名信息 迭代查询：向根服务器查询，根服务器则告诉你，你应该找谁，以此循环","categories":[],"tags":[{"name":"应用层","slug":"应用层","permalink":"https://lvlanbing.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"进程状态","slug":"进程状态","date":"2021-11-23T12:29:59.000Z","updated":"2022-01-10T08:19:10.971Z","comments":true,"path":"2021/11/23/进程状态/","link":"","permalink":"https://lvlanbing.github.io/2021/11/23/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/","excerpt":"进程的5种状态：创建，就绪，运行，阻塞，完成 在用户编写程序使用fork()函数可以创建子进程 12pid_t pid;pid = fork();","text":"进程的5种状态：创建，就绪，运行，阻塞，完成 在用户编写程序使用fork()函数可以创建子进程 12pid_t pid;pid = fork(); 用户是调用了内核中fork.c中的函数（linux-0.11/kernel/fork.c），其中主要copy_process()函数起作用（复制进程） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** OK，下面是主要的fork 子程序。它复制系统进程信息(task[n])并且设置必要的寄存器。* 它还整个地复制数据段。*/// 复制进程。int copy_process (int nr, long ebp, long edi, long esi, long gs, long none, long ebx, long ecx, long edx, long fs, long es, long ds, long eip, long cs, long eflags, long esp, long ss)&#123; struct task_struct *p; int i; struct file *f; struct i387_struct *p_i387; //**开始创建进程** p = (struct task_struct *) get_free_page (); // 为新任务数据结构分配内存。 if (!p) // 如果内存分配出错，则返回出错码并退出。 return -EAGAIN; task[nr] = p; // 将新任务结构指针放入任务数组中。// 其中nr 为任务号，由前面find_empty_process()返回。 *p = *current; /* NOTE! this doesn&#x27;t copy the supervisor stack *//* 注意！这样做不会复制超级用户的堆栈 （只复制当前进程内容）。*/ p-&gt;state = TASK_UNINTERRUPTIBLE; // 将新进程的状态先置为不可中断等待状态。 p-&gt;pid = last_pid; // 新进程号。由前面调用find_empty_process()得到。 p-&gt;father = current-&gt;pid; // 设置父进程号。 p-&gt;counter = p-&gt;priority; p-&gt;signal = 0; // 信号位图置0。 p-&gt;alarm = 0; p-&gt;leader = 0; /* process leadership doesn&#x27;t inherit *//* 进程的领导权是不能继承的 */ p-&gt;utime = p-&gt;stime = 0; // 初始化用户态时间和核心态时间。 p-&gt;cutime = p-&gt;cstime = 0; // 初始化子进程用户态和核心态时间。 p-&gt;start_time = jiffies; // 当前滴答数时间。// jiffies 表示从开机时到现在发生的时钟中断次数// 以下设置任务状态段TSS 所需的数据（参见列表后说明）。 p-&gt;tss.back_link = 0; p-&gt;tss.esp0 = PAGE_SIZE + (long) p; // 堆栈指针（由于是给任务结构p 分配了1 页// 新内存，所以此时esp0 正好指向该页顶端）。 p-&gt;tss.ss0 = 0x10; // 堆栈段选择符（内核数据段）[??]。 p-&gt;tss.eip = eip; // 指令代码指针。 p-&gt;tss.eflags = eflags; // 标志寄存器。 p-&gt;tss.eax = 0; p-&gt;tss.ecx = ecx; p-&gt;tss.edx = edx; p-&gt;tss.ebx = ebx; p-&gt;tss.esp = esp; p-&gt;tss.ebp = ebp; p-&gt;tss.esi = esi; p-&gt;tss.edi = edi; p-&gt;tss.es = es &amp; 0xffff; // 段寄存器仅16 位有效。 p-&gt;tss.cs = cs &amp; 0xffff; p-&gt;tss.ss = ss &amp; 0xffff; p-&gt;tss.ds = ds &amp; 0xffff; p-&gt;tss.fs = fs &amp; 0xffff; p-&gt;tss.gs = gs &amp; 0xffff; p-&gt;tss.ldt = _LDT (nr); // 该新任务nr 的局部描述符表选择符（LDT 的描述符在GDT 中）。 p-&gt;tss.trace_bitmap = 0x80000000;// 如果当前任务使用了协处理器，就保存其上下文。 p_i387 = &amp;p-&gt;tss.i387; if (last_task_used_math == current) _asm&#123; mov ebx, p_i387 clts fnsave [p_i387] &#125;// __asm__ (&quot;clts ; fnsave %0&quot;::&quot;m&quot; (p-&gt;tss.i387));// 设置新任务的代码和数据段基址、限长并复制页表。如果出错（返回值不是0），则复位任务数组中// 相应项并释放为该新任务分配的内存页。 if (copy_mem (nr, p)) &#123; // 返回不为0 表示出错。 task[nr] = NULL; free_page ((long) p); return -EAGAIN; &#125;// 如果父进程中有文件是打开的，则将对应文件的打开次数增1。 for (i = 0; i &lt; NR_OPEN; i++) if (f = p-&gt;filp[i]) f-&gt;f_count++;// 将当前进程（父进程）的pwd, root 和executable 引用次数均增1。 if (current-&gt;pwd) current-&gt;pwd-&gt;i_count++; if (current-&gt;root) current-&gt;root-&gt;i_count++; if (current-&gt;executable) current-&gt;executable-&gt;i_count++;// 在GDT 中设置新任务的TSS 和LDT 描述符项，数据从task 结构中取。// 在任务切换时，任务寄存器tr 由CPU 自动加载。 set_tss_desc (gdt + (nr &lt;&lt; 1) + FIRST_TSS_ENTRY, &amp;(p-&gt;tss)); set_ldt_desc (gdt + (nr &lt;&lt; 1) + FIRST_LDT_ENTRY, &amp;(p-&gt;ldt)); //**进程创建完成，则程序进入到就绪态，等待运行** p-&gt;state = TASK_RUNNING; /* do this last, just in case *//* 最后再将新任务设置成可运行状态，以防万一 */ return last_pid; // 返回新进程号（与任务号是不同的）。&#125; 创建 ——&gt; 就绪 现在进程在就绪队列中等待分配CPU资源运行。 当一个进程在CPU结束运行后如何在就绪队列中选择进程运行呢？ 根据等待的顺序来选择 根据优先级高低来选择 根据短任务优先（分配的时间片短） 在Linux0.11中 linux-0.11/kernel/sched.c调度算法如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * &#x27;schedule()&#x27;是调度函数。这是个很好的代码！没有任何理由对它进行修改，因为它可以在所有的 * 环境下工作（比如能够对IO-边界处理很好的响应等）。只有一件事值得留意，那就是这里的信号 * 处理代码。 * 注意！！任务0 是个闲置(&#x27;idle&#x27;)任务，只有当没有其它任务可以运行时才调用它。它不能被杀 * 死，也不能睡眠。任务0 中的状态信息&#x27;state&#x27;是从来不用的。 */void schedule (void)&#123; int i, next, c; struct task_struct **p; // 任务结构指针的指针。/* 检测alarm（进程的报警定时值），唤醒任何已得到信号的可中断任务 */// 从任务数组中最后一个任务开始检测alarm。 for (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p) if (*p) &#123;// 如果任务的alarm 时间已经过期(alarm&lt;jiffies),则在信号位图中置SIGALRM 信号，然后清alarm。// jiffies 是系统从开机开始算起的滴答数（10ms/滴答）。定义在sched.h 第139 行。 if ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123; (*p)-&gt;signal |= (1 &lt;&lt; (SIGALRM - 1)); (*p)-&gt;alarm = 0; &#125;// 如果信号位图中除被阻塞的信号外还有其它信号，并且任务处于可中断状态，则置任务为就绪状态。// 其中&#x27;~(_BLOCKABLE &amp; (*p)-&gt;blocked)&#x27;用于忽略被阻塞的信号，但SIGKILL 和SIGSTOP 不能被阻塞。 if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp; (*p)-&gt;state == TASK_INTERRUPTIBLE) (*p)-&gt;state = TASK_RUNNING; //置为就绪（可执行）状态。 &#125; /* 这里是调度程序的主要部分 */ while (1) &#123; c = -1; next = 0; i = NR_TASKS;//进程的数量 64 p = &amp;task[NR_TASKS];// 这段代码也是从任务数组的最后一个任务开始循环处理，并跳过不含任务的数组槽。比较每个就绪// 状态任务的counter（任务运行时间的递减滴答计数）值，哪一个值大，运行时间还不长，next 就// 指向哪个的任务号。 while (--i) &#123; if (!*--p) continue;//**counter是时间片也是优先等级，时间片越大优先级就越高//找出counter最大的一个进程，最为下一个运行的程序** if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i; &#125; // 如果比较得出有counter 值大于0 的结果，则退出124 行开始的循环，执行任务切换（141 行）。 if (c) break; // 否则就根据每个任务的优先权值，更新每一个任务的counter 值，然后回到125 行重新比较。 // counter 值的计算方式为**counter = counter /2 + priority**。[右边counter=0??]//**把所的进程更新时间片** for (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p) if (*p) (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) + (*p)-&gt;priority; &#125; switch_to (next); // 切换到任务号为next 的任务，并运行之。&#125; 注意到这里的counter和priority在Linux0.11设置为15，15的 就绪态 ——&gt; 运行态 当时间片使用完后，该进程还没有执行完需要再分配时间片。 也就是上述代码所示：目前的进程在与下一个进程切换，目前的进程只在时钟中断、int0x80中断和进程结束才会切换到下一个进程。而在schedule()函数中只涉及时间片，则判断当前进程的时间片使用完了。如果当前的进程还需要运行则把运行态 ——&gt; 就绪态，等待下一次的调用。而下一个进程从就绪态 ——&gt; 运行态。 一个进程除了在CPU在执行任务，也会读取磁盘上的信息，这个时候进程就会释放CPU的资源，让给其他的进程。这个时候该进程就阻塞了，相对与CPU来说。 123456789101112131415//// **pause()系统调用**。转换当前任务的状态为可中断的等待状态，并重新调度。// 该系统调用将导致进程进入睡眠状态，直到收到一个信号。该信号用于终止进程或者使进程调用// 一个信号捕获函数。只有当捕获了一个信号，并且信号捕获处理函数返回，pause()才会返回。// 此时pause()返回值应该是-1，并且errno 被置为EINTR。这里还没有完全实现（直到0.95 版）。int sys_pause(void)&#123; //把当前的进程的状态设置为阻塞态 current-&gt;state = TASK_INTERRUPTIBLE; if(current-&gt;pid != 0) &#123; //fprintk(3,&quot;%d\\tW\\t%d\\n&quot;,current-&gt;pid,jiffies); &#125; //切换进程使用CPU schedule(); return 0;&#125; 当一个运行的进程可能发生不可中断睡眠状态和可中断睡眠状态时，会释放CPU资源，则进程状态：运行态 ——&gt; 阻塞态。之后调用shedule()函数把CPU资源给下一个进程使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 把当前任务置为不可中断的等待状态，并让睡眠队列头的指针指向当前任务。// 只有明确地唤醒时才会返回。该函数提供了进程与中断处理程序之间的同步机制。// sleep_on()自愿地放弃CPU的使用权void sleep_on(struct task_struct **p)&#123; struct task_struct *tmp; if (!p) return; if (current == &amp;(init_task.task)) panic(&quot;task[0] trying to sleep&quot;); tmp = *p;// 让tmp 指向已经在等待队列上的任务(如果有的话) *p = current;// 将睡眠队列头的等待指针指向当前任务。 //不可中断睡眠 (通常是在IO操作) 收到信号不唤醒和不可运行, //不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。 //只有被使用wake_up()函数明确唤醒时才能转换到可运行的就绪状态** current-&gt;state = TASK_UNINTERRUPTIBLE; //fprintk(3,&quot;%d\\tW\\t%d\\n&quot;,current-&gt;pid,jiffies); schedule(); // 唤醒队列中的上一个（tmp）睡眠进程。0 换作 TASK_RUNNING 更好/* 依次唤醒，所以不可中断的睡眠进程一定是按严格从“队列”（一个依靠 * 放在进程内核栈中的指针变量tmp维护的队列）的首部进行唤醒。而对于可 * 中断的进程，除了用wake_up唤醒以外，也可以用信号（给进程发送一个信 * 号，实际上就是将进程PCB中维护的一个向量的某一位置位，进程需要在合 * 适的时候处理这一位。感兴趣的实验者可以阅读有关代码）来唤醒 */** if (tmp) &#123; tmp-&gt;state=0; //fprintk(3,&quot;%d\\tJ\\t%d\\n&quot;,tmp-&gt;pid,jiffies); &#125;&#125;// 将当前任务置为可中断的等待状态，并放入*p 指定的等待队列中。参见列表后对sleep_on()的说明。// **当进程处于可中断等待状态时，系统不会调度该进程执行。// 当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，// 都可以唤醒进程转换到就绪状态（运行状态）。**void interruptible_sleep_on (struct task_struct **p)&#123; struct task_struct *tmp; if (!p) return; if (current == &amp;(init_task.task)) panic (&quot;task[0] trying to sleep&quot;); tmp = *p; *p = current;repeat: current-&gt;state = TASK_INTERRUPTIBLE; schedule ();// 如果等待队列中还有等待任务，并且队列头指针所指向的任务不是当前任务时，则将该等待任务置为// 可运行的就绪状态，并重新执行调度程序。当指针*p 所指向的不是当前任务时，表示在当前任务被放// 入队列后，又有新的任务被插入等待队列中，因此，既然本任务是可中断的，就应该首先执行所有// 其它的等待任务。 if (*p &amp;&amp; *p != current) &#123; (**p).state = 0; goto repeat; &#125;// 下面一句代码有误，应该是*p = tmp，让队列头指针指向其余等待任务，否则在当前任务之前插入// 等待队列的任务均被抹掉了。参见图4.3。// 唤醒队列中的上一个（tmp）睡眠进程。0 换作 TASK_RUNNING 更好**// 在记录进程被唤醒时一定要考虑到这种情况，实验者一定要注意!!! *p = NULL; if (tmp) tmp-&gt;state = 0;&#125; 在阻塞态的进程等待除CPU资源外的资源，资源到了后需要唤醒进程 123456789// 唤醒指定任务*p。void wake_up (struct task_struct **p)&#123; if (p &amp;&amp; *p) &#123; (**p).state = 0; // 置为就绪（可运行）状态。 *p = NULL; &#125;&#125; 这时就把阻塞态 ——&gt; 就绪态 比如父进程等待子进程都结束后才开始运行，该父进程就存在调用系统等待 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int sys_waitpid(pid_t pid,unsigned long * stat_addr, int options)&#123; int flag, code; struct task_struct ** p; verify_area(stat_addr,4);repeat: flag=0; for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) &#123; if (!*p || *p == current) continue; if ((*p)-&gt;father != current-&gt;pid) continue; if (pid&gt;0) &#123; if ((*p)-&gt;pid != pid) continue; &#125; else if (!pid) &#123; if ((*p)-&gt;pgrp != current-&gt;pgrp) continue; &#125; else if (pid != -1) &#123; if ((*p)-&gt;pgrp != -pid) continue; &#125; switch ((*p)-&gt;state) &#123; case TASK_STOPPED: if (!(options &amp; WUNTRACED)) continue; put_fs_long(0x7f,stat_addr); return (*p)-&gt;pid; case TASK_ZOMBIE: current-&gt;cutime += (*p)-&gt;utime; current-&gt;cstime += (*p)-&gt;stime; flag = (*p)-&gt;pid; code = (*p)-&gt;exit_code; release(*p); put_fs_long(code,stat_addr); return flag; default: flag=1; continue; &#125; &#125; if (flag) &#123; if (options &amp; WNOHANG) return 0; //设置成可中断睡眠状态 // 父进程受到子进程执行完后的信号这就变成就绪态** current-&gt;state=TASK_INTERRUPTIBLE; fprintk(3,&quot;%d\\tW\\t%d\\n&quot;,current-&gt;pid,jiffies); schedule(); if (!(current-&gt;signal &amp;= ~(1&lt;&lt;(SIGCHLD-1)))) goto repeat; else return -EINTR; &#125; return -ECHILD;&#125; 运行态 ——&gt; 结束 12345678910111213141516171819202122232425262728293031323334int do_exit(long code)&#123; int i; free_page_tables(get_base(current-&gt;ldt[1]),get_limit(0x0f)); free_page_tables(get_base(current-&gt;ldt[2]),get_limit(0x17)); for (i=0 ; i&lt;NR_TASKS ; i++) if (task[i] &amp;&amp; task[i]-&gt;father == current-&gt;pid) &#123; task[i]-&gt;father = 1; if (task[i]-&gt;state == TASK_ZOMBIE) /* assumption task[1] is always init */ (void) send_sig(SIGCHLD, task[1], 1); &#125; for (i=0 ; i&lt;NR_OPEN ; i++) if (current-&gt;filp[i]) sys_close(i); iput(current-&gt;pwd); current-&gt;pwd=NULL; iput(current-&gt;root); current-&gt;root=NULL; iput(current-&gt;executable); current-&gt;executable=NULL; if (current-&gt;leader &amp;&amp; current-&gt;tty &gt;= 0) tty_table[current-&gt;tty].pgrp = 0; if (last_task_used_math == current) last_task_used_math = NULL; if (current-&gt;leader) kill_session(); **current-&gt;state = TASK_ZOMBIE;** fprintk(3,&quot;%d\\tE\\t%d\\n&quot;,current-&gt;pid,jiffies); current-&gt;exit_code = code; tell_father(current-&gt;father); schedule(); return (-1); /* just to suppress warnings */&#125;","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://lvlanbing.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"进程","permalink":"https://lvlanbing.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"HTTP_Server","slug":"HTTP-Server","date":"2021-11-22T10:23:49.000Z","updated":"2021-11-22T11:03:36.178Z","comments":true,"path":"2021/11/22/HTTP-Server/","link":"","permalink":"https://lvlanbing.github.io/2021/11/22/HTTP-Server/","excerpt":"Web服务器是基于HTTP实现的，而HTTP协议是运行在TCP之上的。所以在创建TCP连接这个过程是与C/S的过程是相似的。","text":"Web服务器是基于HTTP实现的，而HTTP协议是运行在TCP之上的。所以在创建TCP连接这个过程是与C/S的过程是相似的。 123456789101112131415161718192021222324252627282930313233//创建服务 int client_socket = -1; int server_socket = -1; u_short port = 8080; struct sockaddr_in client_name; int len = sizeof(client_socket); struct sockaddr_in server_name; pthread_t newthread; //PF_INET if((server_socket = socket(PF_INET,SOCK_STREAM,0)) &lt; 0)&#123; perror(&quot;socket&quot;); return 1; &#125; memset(&amp;server_name,0,sizeof(server_name)); server_name.sin_addr.s_addr = htonl(INADDR_ANY); server_name.sin_family = AF_INET; server_name.sin_port = htons(port); if(bind(server_socket, (struct sockaddr*)&amp;server_name, sizeof(server_name)) &lt; 0) &#123; perror(&quot;bind&quot;); return 1; &#125; if(listen(server_socket,5)) &#123; perror(&quot;listen&quot;); return 1; &#125; client_socket = accept(server_socket, (struct sockaddr*)&amp;client_name, (socklen_t*)&amp;len); Web接收到的信息是去掉TCP的头部，但是还有HTTP的头部。Web则是根据该头部的信息进行逻辑控制。一个Web服务器支持多个客户端，不同的套接字可以使用相同的端口号。 需要自己去解析HTTP的头部，来判断接下来服务器的动作。 根据HTTP头部的格式，我们一行行的读取信息 123456789101112131415161718192021222324252627// 读取套接字的一行，把回车换行等情况都统一为换行符结束。// 把读取到的信息存储到buf指针中int get_line(int sock, char *buf, int size) &#123; int i = 0; char c = &#x27;\\0&#x27;; int n; while((i &lt; size - 1) &amp;&amp; (c != &#x27;\\n&#x27;)) &#123; n = recv(sock, &amp;c, 1, 0); if(n &gt; 0) &#123; if(c == &#x27;\\r&#x27;) &#123; //MSG_PEEK时代表只是查看数据，而不取走数据 n = recv(sock, &amp;c, 1, MSG_PEEK); if((n &gt; 0) &amp;&amp; (c==&#x27;\\n&#x27;)) recv(sock,&amp;c,1,0); else c = &#x27;\\n&#x27;; &#125; buf[i] = c; i++; &#125; else c = &#x27;\\n&#x27;; &#125; buf[i] = &#x27;\\0&#x27;; printf(&quot;buf : %s\\n&quot;,buf); return (i);&#125; 读取到信息后，需要判断请求的方法为POST还是GET，HTTP的版本，请求的文件是否存在等。 如果进行顺利，我们需要向客户端发送响应同时发送请求的信息。 通过HTTP的GET的方法，将输入的数据作为参数添加在URI后面发送给服务器。而POST则将数据放在HTTP请求消息的消息体中发送给服务器。 HTTP/1.0使用非持久连接 HTTP/1.1使用持久连接 非持久连接：Web服务器在发送一个对象资源就要使用一个TCP连接。最多只有一个对象在TCP连接上发送。下载多个对象需要多个TCP连接。 持久连接:多个对象可以在一个TCP连接上传输 比如： 当请求的默认网页中含有图片等对象，这是默认网页就不只有一个对象了。非持久连接则会发生多次的HTTP连接的过程，也就每个对象都花费一个RTT（往返时间）。持久连接一次请求完所有对象（客户端遇到一个引用对象就立即产生一个请求），所有的引用可能花费一个RTT。引用是在网页中的。 200 OK ： 请求成功，请求对象包含在响应报文的后续部分301 Moved Permanently ：请求的对象已经被永久转移了；新的URL在响应报文的Location:首部行中指定；客户端软件自动用新的URL去获取对象400 Bad Request： 一个通用的差错代码，表示该请求不能被服务器解读404 Not Found ： 请求的文档在该服务上没有找到505 HTTP Version Not Supported 上述的Web服务器是无法支持维护用户的状态的。比如我们平常的网络购物，购物车，历史记录等。则使用一个Cookies来维护状态。 HTTP的请求报文和响应报文中都有一个cookies的首行 用户端系统中保存有一个cookies文件，有用户浏览器管理 在Web站点有一个后端数据库 cookies的运行过程 Web缓存 如果每个客户端都访问一个Web服务器，那么他的载荷太大，容易崩溃的。怎样不访问原始服务器，就满足客户的请求。就出现了Web缓存。 好处： 降低客户端的请求响应时间 减少一个机构内部网络与Internet接入链路上的流量 客户端请求的对象在缓存器中不是最新的，则转向原Web服务器。原Web服务器把对象发送给客户端，同时更新缓存器中的对象。是通过HTTP头部中last-modified字段来判断的 缓存器","categories":[],"tags":[{"name":"应用层","slug":"应用层","permalink":"https://lvlanbing.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"网络编程","slug":"网络编程","permalink":"https://lvlanbing.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"TCP_Socket","slug":"TCP-Socket","date":"2021-11-22T10:17:39.000Z","updated":"2021-11-22T11:04:06.602Z","comments":true,"path":"2021/11/22/TCP-Socket/","link":"","permalink":"https://lvlanbing.github.io/2021/11/22/TCP-Socket/","excerpt":"进程通信 这里的进程通信是基于网络的通信 进程 进程可以在终端中查看到进程的基本属性。其中在网络通信中最重要的是PID（进程ID，也就是端口号），这样可以在主机上唯一的表示进程。 在同台主机上，不同的进程可以通过共享内存、管道、信号量和消息队列等。但是在不同的主机下只有通过网络（socket）进行通信。这里我们假设网络通道已经建立好，现在我们只需要使用就可以了。 现在有一个问题：一台主机如何找到我要交流的主机呢？ 这里就引出了IP这个概念。每一个主机都有一个唯一的IP地址，就像你的家都有一个唯一的地址一样。当你想要与目的主机交流时，就需要提前知道对方的IP地址及PID。 网络提供了什么样的服务。（这里的网络指的是传输层及以下的） 我们可以使用socket进行网络编码。socket又分为：TCP socket，UDP socket 和Raw socket。我们主要使用TCP和UDP套接字。","text":"进程通信 这里的进程通信是基于网络的通信 进程 进程可以在终端中查看到进程的基本属性。其中在网络通信中最重要的是PID（进程ID，也就是端口号），这样可以在主机上唯一的表示进程。 在同台主机上，不同的进程可以通过共享内存、管道、信号量和消息队列等。但是在不同的主机下只有通过网络（socket）进行通信。这里我们假设网络通道已经建立好，现在我们只需要使用就可以了。 现在有一个问题：一台主机如何找到我要交流的主机呢？ 这里就引出了IP这个概念。每一个主机都有一个唯一的IP地址，就像你的家都有一个唯一的地址一样。当你想要与目的主机交流时，就需要提前知道对方的IP地址及PID。 网络提供了什么样的服务。（这里的网络指的是传输层及以下的） 我们可以使用socket进行网络编码。socket又分为：TCP socket，UDP socket 和Raw socket。我们主要使用TCP和UDP套接字。 现在我们来整理一下： 一台主机有许多的进程，我们使用PID来区分这些进程。同时进程也使用PID来找到要进行通信的进程。而不同主机则是使用IP进行标识，主机通信与上述的PID的相似。 现在可以知道一个进程进行网络通信，需要知道对方的主机IP和进程的PID。这和我们信封通信很相似。注意：你在与对方通信时也要说明，你的IP和PID，这样对方才能给你返信阿。 而我们通信的方式（也就是运输的方式）主要有三种， 每种方式要准备的东西是不同的（汽车，火车、飞机）。 现在对网络的通信应该有大致的了解吧。 TCP套接字还是以信封通信为例。 经常通信的两人并且他们的地址不会发生改变。你不会觉得每次填写地址等信息感到效率低嘛？ 这就提出了套接字这个概念，大致就是使用一个整数来表示对方和自己的地址等信息，再之后的通信只需要提交一个整数就可以了。也就是你常去邮局给我寄信，邮局的人每次都知道。久而久之，你来邮局就不用再填写那些地址信息，邮局自动就帮你做了。 这个整数是一个具有本地意义的标示，对方是不可见的。你去到对方的邮局当然没这种效果了阿！ 对于TCP套接字这个整数表示：(源IP，源port，目标IP，目标port)。不必在每个报文的发送都要指定这4元组。 服务端创建TCP套接字 123456int serverSocket,connectSocket;//如果不是TCP套接字，则socket中的参数需要修改if((serverSocket = socket(AF_INET, SOCK_STREAM,0)) &lt; 0)&#123; perror(&quot;socket&quot;); return 1; &#125; 初始化主机状态 1234567891011struct sockaddr_in server_addr;u_short port = 2344;memset((char*)&amp;server_addr, 0, sizeof(server_addr));//INADDR_ANY就是指定地址为0.0.0.0的地址，这个地址事实上表示不确定地址，//或“所有地址”、“任意地址”。server_addr.sin_addr.s_addr = INADDR_ANY;//协议--ipv4server_addr.sin_family = AF_INET;//端口server_addr.sin_port = htons(port); 指定端口号 1234if(bind(serverSocket,(struct sockaddr *)&amp;server_addr, sizeof(server_addr)) &lt; 0)&#123; perror(&quot;bind&quot;); return 1; &#125; 监听，最大连接数量 1234if(listen(serverSocket, 5) &lt; 0)&#123; perror(&quot;listen&quot;); return 1; &#125; 等待连接 123int serverSocket,connectSocket;connectSocket = accept(serverSocket, (struct sockaddr*)&amp;client_addr, (socklen_t *)&amp;addr_len); 现在双方连接以及建立，就可以开始通信了。recv接收信息，send发送信息 9999则对应connectSocket 客户端创建套接字 12345int clientSocket;if((clientSocket = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123; perror(&quot;socket&quot;); return 1; &#125; 初始化连接对象状态 1234struct sockaddr_in server_addr;server_addr.sin_family = AF_INET;server_addr.sin_port = htons(2344);server_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); 客户端在编程是不需要绑定端口，OS会自动绑定的。 连接 12345if(connect(clientSocket, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) &lt; 0) &#123; perror(&quot;connect&quot;); return 1; &#125; 开始信息交流","categories":[],"tags":[{"name":"应用层","slug":"应用层","permalink":"https://lvlanbing.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"网络编程","slug":"网络编程","permalink":"https://lvlanbing.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"hexo blog","slug":"hexo-blog","date":"2021-11-17T06:51:01.000Z","updated":"2021-11-17T09:03:56.323Z","comments":true,"path":"2021/11/17/hexo-blog/","link":"","permalink":"https://lvlanbing.github.io/2021/11/17/hexo-blog/","excerpt":"安装环境：Ubuntu","text":"安装环境：Ubuntu 安装nodejs and npm12345678910//先升级安装工具sudo apt-get updatesudo apt-get upgrade//安装sudo apt-get install nodejs-legacy nodejs//或者sudo apt-get install nodesudo apt-get install npm 当遇到版本低时 12345//node有一个模块叫n，是专门用来管理node.js的版本。npm install -g n//升级node.js到最新稳定版n stable//n后面也可以跟随版本号 查看安装是否成功 12node -vnpm -v 现在安装hexo123npm i hexo-cli -g//验证是否成功hexo -v 建立blog创建一个blog目录（mkdir blogName），使用hexo init初始化文件夹，接着npm install安装必备的组件 123hexo g //生成静态网页hexo s //启动本地服务hexo d //上传，目前还没有配置好，无法使用 目前应该能启动一个简单的页面了 更换主题在blog目录下的themes文件夹下放置你自己的主题。 同时需要修改blog目录下的_config.yml中theme：name字段，name为你主题的文件夹名 主题：git clone –depth=1 https://github.com/JoeyBling/hexo-theme-yilia-plus.git ./yilia-plus 安装git1sudo apt-get install git 链接github ssh-keygen -t rsa -C “GitHub注册邮箱”，然后按提示输入 cat ~/.ssh/id_rsa_pub下面的密钥复制到自己的GitHub上 同时配置_config.yml yilia-plus 出现样式乱码，尝试使用：npm i hexo-generator-json-content –save","categories":[],"tags":[{"name":"安装教程","slug":"安装教程","permalink":"https://lvlanbing.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]}],"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://lvlanbing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"CS144","slug":"CS144","permalink":"https://lvlanbing.github.io/categories/CS144/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://lvlanbing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://lvlanbing.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"https://lvlanbing.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"线程","slug":"线程","permalink":"https://lvlanbing.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"应用层","slug":"应用层","permalink":"https://lvlanbing.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"进程","slug":"进程","permalink":"https://lvlanbing.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"安装教程","slug":"安装教程","permalink":"https://lvlanbing.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]}