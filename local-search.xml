<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS144_lab01</title>
    <link href="/2022/05/13/CS144-lab01/"/>
    <url>/2022/05/13/CS144-lab01/</url>
    
    <content type="html"><![CDATA[<h1 id="Putting-substrings-in-sequence"><a href="#Putting-substrings-in-sequence" class="headerlink" title="Putting substrings in sequence"></a>Putting substrings in sequence</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>输入的数据格式为：一个字符串，该字符串在整个数据的起始位置index，该字符串是不是最后一个的标识。<br><br>目标：把这些无序的字符整理为有序数据。</p><h2 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h2><p>数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">std::deque&lt;<span class="hljs-keyword">char</span>&gt; _buffer  <span class="hljs-comment">// 缓存区</span><br>std::deque&lt;<span class="hljs-keyword">bool</span>&gt; bitmap;    <span class="hljs-comment">// 与缓存区对应，判断bit是否可以发送。</span><br><span class="hljs-keyword">size_t</span> _index  <span class="hljs-comment">// 有序字符的下一个存储在缓存中的下标</span><br><span class="hljs-keyword">bool</span> _eof;    <span class="hljs-comment">// 数据流结束标识</span><br><span class="hljs-keyword">size_t</span> unass_size;    <span class="hljs-comment">// 未重组的个数</span><br></code></pre></td></tr></table></figure><p>1、index大于_index，导致[_index, index)区间出现空白。这就要等待该空白区域填满了之后，才能发送该片段。<br><br>2、index小于_index，就会出现重复的数据。根据index和_index求出偏移，就可以解决。<br><br>注意：只要数据是有序的，就把它交付出去。<br><br>3、最后一个数据段可能提前到了</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++">### <span class="hljs-function">push_substring</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;data, <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> index, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> eof)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span>(eof) &#123;<br>        _eof = eof;<br>    &#125;<br><br>    <span class="hljs-keyword">size_t</span> len = data.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span> &amp;&amp; _eof &amp;&amp; unass_size == <span class="hljs-number">0</span>) &#123;<br>        _output.<span class="hljs-built_in">end_input</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 忽略无效下标</span><br>    <span class="hljs-keyword">if</span>(index &gt;= _index + _capacity) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span>(index &gt;= _index) &#123;<br>        <span class="hljs-keyword">size_t</span> offset = index - _index;     <span class="hljs-comment">// 计算偏移</span><br>        <span class="hljs-keyword">size_t</span> real_len = <span class="hljs-built_in">min</span>(len, _capacity - _output.<span class="hljs-built_in">buffer_size</span>() - offset);<br>        <span class="hljs-keyword">if</span>(real_len &lt; len) &#123;    <span class="hljs-comment">// 数据还没有传输完</span><br>            _eof = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; real_len; ++i) &#123;<br>            <span class="hljs-comment">// 跳过重复数据([_index, A)一直为空白区，但是后面也有多种情况</span><br>            <span class="hljs-keyword">if</span>(bitmap[i + offset]) <span class="hljs-keyword">continue</span>;  <br>            <span class="hljs-comment">// _buffer和bitmap 一一对应  </span><br>            _buffer[i + offset] = data[i];<br>            bitmap[i + offset] = <span class="hljs-literal">true</span>;<br>            unass_size++;   <span class="hljs-comment">// 统计未重组的字符</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index + len &gt; _index) &#123;   <span class="hljs-comment">// 计算与已经传输的字符重复了，去重。</span><br>        <span class="hljs-keyword">size_t</span> offset = _index - index;<br>        <span class="hljs-comment">// 不能超过缓存区</span><br>        <span class="hljs-keyword">size_t</span> real_len = <span class="hljs-built_in">min</span>(len - offset, _capacity - _output.<span class="hljs-built_in">buffer_size</span>());<br>        <span class="hljs-keyword">if</span>(real_len &lt; len - offset) &#123;<br>            _eof = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; real_len; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(bitmap[i]) <span class="hljs-keyword">continue</span>;<br>            _buffer[i] = data[i + offset];  <span class="hljs-comment">// i + offset未重叠的部分</span><br>            bitmap[i] = <span class="hljs-literal">true</span>;<br>            unass_size++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">check_contiguous</span>();<br>    <span class="hljs-keyword">if</span>(_eof &amp;&amp; unass_size == <span class="hljs-number">0</span>) &#123;<br>        _output.<span class="hljs-built_in">end_input</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="check-contiguous"><a href="#check-contiguous" class="headerlink" title="check_contiguous"></a>check_contiguous</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StreamReassembler::check_contiguous</span><span class="hljs-params">()</span> </span>&#123;<br>    string msg = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">while</span>(bitmap.<span class="hljs-built_in">front</span>()) &#123;<br>        msg += _buffer.<span class="hljs-built_in">front</span>();<br>        _buffer.<span class="hljs-built_in">pop_front</span>();<br>        bitmap.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-comment">// 保证缓存区大小固定</span><br>        _buffer.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;\0&#x27;</span>);<br>        bitmap.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(msg.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        _output.<span class="hljs-built_in">write</span>(msg);<br>        unass_size -= msg.<span class="hljs-built_in">length</span>();<br>        _index += msg.<span class="hljs-built_in">length</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP连接的建立和断开</title>
    <link href="/2022/05/13/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%96%AD%E5%BC%80/"/>
    <url>/2022/05/13/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%96%AD%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP连接的建立和断开"><a href="#TCP连接的建立和断开" class="headerlink" title="TCP连接的建立和断开"></a>TCP连接的建立和断开</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>TCP是向应用层提供可靠的传输服务。TCP的下层服务是IP层，而IP层提供的是不可靠的服务。<br>同时TCP的服务是点到点的（port到port），IP是端到端的（主机到主机）。<br><br><br>TCP头部的一些字段要知道。</p><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs">源端口号，目的端口号<br>序号<br>确认号<br>连接建立和断开的字段（SYN，FIN，RST）<br>接收窗口<br></code></pre></td></tr></table></figure><p>序号：开始随机产生一个数（防止有相同的序号），之后下一个序号 = 上一个序号 + 上一个数据的长度。<br>应用层交付的数据可能大于MSS的，所以需要对数据进行分片。<br>确认号：确认数据报是否成功接受到，确认号 = 收到的序号 + 1</p><h2 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h2><p><font color = red>怎样才算连接建立？</font><br><br>像UDP，客户端知道目的端的IP和端口，就可以把数据发送的目的端。<br>TCP同样是发送数据，但是需要建立连接后才能发送数据。<br><br>TCP是为了向上层提供有序，无差错的数据，所以需要建立连接。<br><br>连接建立就像初始化一样。我们有了固定的规则，但是变量没有值。（比如序号，接收窗口等）<br><br>这样客户端要告诉服务端，客户端的情况；服务端要告诉客户端的情况。从这个角度来说，我们两次的握手就可以建立连接了。<br><br><font color = red>为什么连接建立都是三次握手呢？</font><br><br>我们先来看看两次握手为什么不行。<br><br>网络是不稳定的，会出现高延迟，数据报的丢失。客户端在时间t1向服务端发送连接建立请求。客户端在时间t3才接收到服务器的应答。<br>(t1, t3)这个时间段已经超过t1时间的设置的超时时钟，导致客户端在时间t2再次向服务端发送请求。<br><br>上述情况中多了连接的建立次，这会导致服务端压力增大。<br><br>服务端对t1时刻数据报的应答，客户端在（t2，t3）之间接收到。那么客户端有两个连接，就需要发送两个相同的数据报。这样效率低下。<br><br>这就需要三次握手<br><br>解决半连接和接收老数据问题</p><!-- 客户端在t1时刻向服务端发起连接请求。客户端 --><p>当客户端三次握手建立好连接后。中间可以能会出现，客户端再次请求连接。但是服务端应答的确认号A是之前使用过的了。客户端在最后一次的握手，所期待的确认号不是A，所以这次连接会被拒绝掉。这样可以解决客户端发送重复的数据报（在没有超时的情况下）。<br><br><strong>序号，客户端和服务端都会自己随机一个初始值。</strong></p><h2 id="连接断开"><a href="#连接断开" class="headerlink" title="连接断开"></a>连接断开</h2><p>TCP是全双工的，两个方向都要断开。客户端和服务端都可以发起断开请求，但是大多数都是客户端发起断开请求。<br><br>1、客户端到服务端方向的连接断开。<br><br>这时服务端向客户端发送数据，客户端还是能收到。现在处于半关闭状态。<br><br>2、服务端到客户端方向的连接断开<br><br>但是还没有正真的断开连接，因为客户端需要等待2*max segment lifetime（报文段最大生存时间）之后才会关闭连接。</p><h3 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><p>TIME_WAIT状态存在的原因：<br><br>1、可靠地终止TCP连接<br><br>2、保证让迟来的TCP报文段有足够的时间识别并丢弃<br><br>当客户端对服务器断开连接的请求的应答报文<strong>丢失</strong>。如果客户端已接受到服务端的断开请求，客户端就认为连接断开了。那么对于之后服务端的重复发送，不再做任何的应答，这样的断开连接是失败的。所以在接受到服务端的断开请求后，客户端还有维持2*max segment lifetime时间之后才会关闭服务。在这段时间里，能最大限度的保证连接的断开。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs144_lab0</title>
    <link href="/2022/05/10/cs144-lab0/"/>
    <url>/2022/05/10/cs144-lab0/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h1 id="Writing-webget"><a href="#Writing-webget" class="headerlink" title="Writing webget"></a>Writing webget</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;host, <span class="hljs-keyword">const</span> string &amp;path)</span> </span>&#123;<br>    <span class="hljs-comment">// You will need to connect to the &quot;http&quot; service on</span><br>    <span class="hljs-comment">// the computer whose name is in the &quot;host&quot; string,</span><br>    <span class="hljs-comment">// then request the URL path given in the &quot;path&quot; string.</span><br><br>    <span class="hljs-comment">// Then you&#x27;ll need to print out everything the server sends back,</span><br>    <span class="hljs-comment">// (not just one call to read() -- everything) until you reach</span><br>    <span class="hljs-comment">// the &quot;eof&quot; (end of file).</span><br>    TCPSocket ss;<br>    ss.<span class="hljs-built_in">connect</span>(<span class="hljs-built_in">Address</span>(host, <span class="hljs-string">&quot;http&quot;</span>));<br><br>    <span class="hljs-comment">// 模拟http请求头部</span><br>    string str = <span class="hljs-string">&quot;GET &quot;</span>+ path + <span class="hljs-string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="hljs-string">&quot;\r\nConnection: close\r\n\r\n&quot;</span>;<br>    string recv_str;<br>    <span class="hljs-comment">// 向服务器发送</span><br>    ss.<span class="hljs-built_in">write</span>(str);<br>    <span class="hljs-comment">// eof保证接受完</span><br>    <span class="hljs-keyword">while</span>(ss.<span class="hljs-built_in">eof</span>() == <span class="hljs-literal">false</span>) &#123;<br>        ss.<span class="hljs-built_in">read</span>(recv_str);<br>        cout&lt;&lt;recv_str;<br>    &#125;<br>    ss.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="An-in-memory-reliable-byte-stream"><a href="#An-in-memory-reliable-byte-stream" class="headerlink" title="An in-memory reliable byte stream"></a>An in-memory reliable byte stream</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string _buffer = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//缓存区</span><br><span class="hljs-keyword">size_t</span> _capacity = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> _input_ended_flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">size_t</span> _write_count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">size_t</span> _read_count = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;data)</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> len = data.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">if</span>(len &gt; _capacity - _buffer.<span class="hljs-built_in">length</span>()) &#123;<br>        len = _capacity - _buffer.<span class="hljs-built_in">length</span>();<br>    &#125;<br>    _write_count = _write_count + len;<br>    std::string msg = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, len);<br>    _buffer += msg;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="peek-output"><a href="#peek-output" class="headerlink" title="peek_output"></a>peek_output</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">string <span class="hljs-title">ByteStream::peek_output</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> lenght = len;<br>    std::string msg;<br>    <span class="hljs-keyword">if</span>(len &gt; _buffer.<span class="hljs-built_in">size</span>())<br>        lenght = _buffer.<span class="hljs-built_in">size</span>();<br>    msg = _buffer.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, lenght);<br>    <span class="hljs-keyword">return</span> msg;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pop-output"><a href="#pop-output" class="headerlink" title="pop_output"></a>pop_output</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ByteStream::pop_output</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> </span>&#123; <br>    <span class="hljs-keyword">size_t</span> lenght = len;<br>    <span class="hljs-keyword">if</span>(len &gt; _buffer.<span class="hljs-built_in">size</span>())<br>        lenght = _buffer.<span class="hljs-built_in">size</span>();<br>    _read_count += lenght;<br>    _buffer.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, lenght);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::string <span class="hljs-title">ByteStream::read</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    string s = <span class="hljs-built_in">peek_output</span>(len);<br>    <span class="hljs-built_in">pop_output</span>(len);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ByteStream::end_input</span><span class="hljs-params">()</span> </span>&#123;_input_ended_flag = <span class="hljs-literal">true</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ByteStream::input_ended</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _input_ended_flag; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::buffer_size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _buffer.<span class="hljs-built_in">size</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ByteStream::buffer_empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _buffer.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ByteStream::eof</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">buffer_empty</span>() &amp;&amp; <span class="hljs-built_in">input_ended</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::bytes_written</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _write_count; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::bytes_read</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _read_count; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::remaining_capacity</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _capacity - _buffer.<span class="hljs-built_in">size</span>(); &#125;<br></code></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当程序逻辑完全正确的情况。执行make check_lab0, 可能会出现以下问题</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[100%] Testing Lab 0...<br><span class="hljs-keyword">Test </span>project /home/ubuntu/CS144_2021/lab0/sponge/build<br>    Start 26: t_byte_stream_construction<br>1/9 Test #26: t_byte_stream_construction .......***Failed    0.00 sec<br><span class="hljs-keyword">Test </span>Failure on expectation:<br>        Expectation: buffer_empty: 1<br><br><span class="hljs-keyword">Failure </span>message:<br>        The ByteStream should have had buffer_empty equal to 1 but instead it was 0<br><br>List of steps that executed successfully:<br>        Initialized with (capacity=15)<br>        Expectation: input_ended: 0<br><br>Exception: The test &quot;construction&quot; failed<br>.........<br>5/9 Test #30: t_byte_stream_many_writes ........***Failed    0.00 sec<br><span class="hljs-keyword">Test </span>Failure on expectation:<br>             Action: write &quot;xrvebsengdwiqtkslspvlftaqaadlafzowwevyeqmyokuxdmgnbfjiilhczumsxolkvdcpficcgnigauadmpnlgalffifjhgnzydbzrjtcpwsmhujsbjzcptbifgiynnodjbbbjnpwrmffcctvcwx&quot; to the stream<br><br><span class="hljs-keyword">Failure </span>message:<br>        The ByteStream should have had bytes_written equal to 149 but instead it was 0<br><br>List of steps that executed successfully:<br>        Initialized with (capacity=200000)<br><br>Exception: The test &quot;many writes&quot; failed<br>.....<br></code></pre></td></tr></table></figure><p>这时需要重新对整个项目make一下，之后再执行make check_lab0</p>]]></content>
    
    
    <categories>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144_notes</title>
    <link href="/2022/05/09/CS144-notes/"/>
    <url>/2022/05/09/CS144-notes/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">To run <span class="hljs-keyword">the</span> labs, you’ll need <span class="hljs-keyword">the</span> following software:<br><br>g++ <span class="hljs-built_in">version</span> <span class="hljs-number">8.</span>x<br>clang-tidy <span class="hljs-built_in">version</span> <span class="hljs-number">6</span> <span class="hljs-keyword">or</span> <span class="hljs-number">7</span><br>clang-<span class="hljs-built_in">format</span> <span class="hljs-built_in">version</span> <span class="hljs-number">6</span> <span class="hljs-keyword">or</span> <span class="hljs-number">7</span><br>cmake <span class="hljs-built_in">version</span> <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> later<br>libpcap development headers (libpcap-dev <span class="hljs-keyword">on</span> <span class="hljs-title">Debian-like</span> <span class="hljs-title">distributions</span>)<br>git<br>iptables<br>mininet <span class="hljs-number">2.2</span><span class="hljs-number">.0</span> <span class="hljs-keyword">or</span> later<br>tcpdump<br>telnet<br>wireshark<br>socat<br>netcat-openbsd<br>GNU coreutils<br>bash<br>doxygen<br>graphviz<br>Note: there are <span class="hljs-keyword">at</span> least <span class="hljs-literal">three</span> versions <span class="hljs-keyword">of</span> netcat. You won’t be <span class="hljs-keyword">using</span> <span class="hljs-keyword">it</span> much, but when you <span class="hljs-built_in">do</span>, we will assume you’ve got <span class="hljs-keyword">the</span> OpenBSD variant. Others might also work, though <span class="hljs-keyword">it</span> is possible that they will <span class="hljs-built_in">require</span> different commandline flags.<br><br>We’ve tested <span class="hljs-keyword">the</span> labs <span class="hljs-keyword">with</span> recent Debian-derived systems (Ubuntu <span class="hljs-number">18.04</span> <span class="hljs-keyword">and</span> similar) <span class="hljs-keyword">and</span> Arch Linux. In all likelihood, other modern Linux distributions will also work.<br></code></pre></td></tr></table></figure><h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><p>g++ -v or gcc -v的版本是小于8，就会导致cmake的时候失败<br><br><br>解决：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br>sudo apt-<span class="hljs-built_in">get</span> install gcc-<span class="hljs-number">8</span><br>sudo apt-<span class="hljs-built_in">get</span> install g++-<span class="hljs-number">8</span><br><span class="hljs-keyword">cd</span> /usr/bin<br>sudo rm gcc g++<br>sudo <span class="hljs-keyword">ln</span> -s gcc-<span class="hljs-number">8</span> gcc<br>sudo <span class="hljs-keyword">ln</span> -s g++-<span class="hljs-number">8</span> g++<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程切换</title>
    <link href="/2021/11/29/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    <url>/2021/11/29/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>进程：指令执行序列+资源。进程的切换除了PC指针（程序计数器，存放下一条指令地址）的变化，映射表（资源）也要发生变化。</p><p>线程：一个进程中有多个线程，它们共用该进程中的资源。所以线程的切换不需要对资源进行切换。线程的切换的速度就要比进程的切换要快很多。</p><span id="more"></span><p>先说线程的切换</p><p>线程A在切换到线程C的时候需要保存线程A之前运行的结果和之后又要重那里接着运行的地址。</p><p>这里我们使用栈来保存</p><p><img src="Untitled.png" alt="Untitled"></p><p>上图是两个线程使用一个栈，其中数字对应着地址。Yeild函数指定切换到那里。在用户态可以自己编写切换程序，但是在内核中只能使用内核的切换算法了。</p><p>想一想这样做能成功的从<code>2</code>准确的回到<code>3</code>并正常运行？</p><p>当回到(3)处，遇到“}”时要出栈。出栈的第一个地址为404，现在有回到另一个线程。然后执行404后的代码再遇到”}”时有出栈，地址为304。这就切换失败了，但是能切换。</p><p>如果每个线程都有自己的栈会不会更好一点。这就出现每个线程都有自己的线程控制块（TCB）。每个栈都与TCB进行关联。当前栈的栈顶地址是存放在CPU里面的<code>esp</code>寄存器里面的， 因此只需要改变<code>esp</code>的值就可以切换栈了</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Yield</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>TCB2.esp = esp;<span class="hljs-comment">// 保存当前栈顶地址</span><br>esp = TCB1.esp;<span class="hljs-comment">// 切换栈</span><br>jmp <span class="hljs-number">204</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在(3)后遇到“}”后根据栈出了的地址为204。我们想要的是回到104地址了，还是失败了，但是并没有在另一个线程中了。</p><p>解决：</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>就是把Yield中的 jmp 204 地址去到。也就是在Yield中的函数中“}”时就把204地址弹出了，再遇到B()中的”}”时弹出来的就是104地址了。</p><p>现在就线程切换的思路了。</p><p>目前只是用户态下的切换，并没有涉及到内核态。</p><p>问题：<del>用户态线程内核是不知道的，当用户态中的一个线程要去访问磁盘资源，内核不知道，就让该进程继续使用CPU资源，但是它并没有在使用CPU。这就造成了资源的浪费。</del></p><p>用户态一个进程有多个线程，当一个线程阻塞了。内核是看不到用户的线程，则就把进程切换了。导致进程中的线程无法切换了。</p><p><img src="Untitled%202.png" alt="Untitled"></p><p>多核处理器用的是同一个MMU（Memory Management Unit），这就是多线程模式。则内核级线程技术，能更好的发挥硬件的优势。</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>用户级线程与内核级线程：</p><p>用户级线程在发生中断才能进入到内核级线程</p><p>内核级线程是要在内核中执行的程序。则内核级线程需要在用户态和核心态里跑，用户态有一个用户栈，核心态中有一个核心栈。用户栈和核心栈称为一套栈。</p><br><p>同又出现了一个新的问题就是：用户态的线程怎么和内核态下的线程协同合作呢？</p><p>用户栈与内核栈之间的关联。</p><p>一个栈到一套栈；两个栈到两套栈。用户态下的栈与内核态下的栈关联起来。</p><p>中断时，线程进入到内核中，OS根据硬件的寄存器来知道这个线程，它对应的内核栈在那里。同时回将用户态的栈的位置（<code>SS，SP</code>）和程序执行到那里的位置<code>（CS(Code Segment)，IP(Instruction Pointer)）</code>都压入内核栈中保存下来。</p><p>线程在内核中执行完，退出内核态回到用户态时（也就是iret指令），就根据之前的内核栈中存入的<code>SS和SP</code>的值来找用户栈，根据<code>CS和PC</code>值找程序接下来该执行的位置。</p><p>例子：</p><p><img src="Untitled%204.png" alt="Untitled"></p><p>在内核中线程的切换是通过switch_to()函数实现的，就是从当前线程的内核栈切换到next线程的内核栈。</p><p>内核级线程的代码还是在用户态的，只是进入内核态完成系统调用，就是逛一圈之后还是要回去执行的。</p><p>线程S切换到线程T要根据线程T的内核栈找到这个线程阻塞的位置，执行线程T的函数。线程T的内核栈之后，通过iret指令从内核栈返回到用户态执行线程T的代码。</p><p>内核级线程的切换五个步骤：</p><ul><li>中断进入内核</li><li>在内核态中，由于启动磁盘或者时钟中断，引发线程切换</li><li>通过TCB对内核栈进行切换</li><li>使用iret推出中断，对用户栈进行切换。内核栈和用户栈都完成了切换</li><li>如果线程不是同一个进程，还需要对内存映射表进行切换</li></ul><h2 id="实验：基于内核栈切换的进程切换"><a href="#实验：基于内核栈切换的进程切换" class="headerlink" title="实验：基于内核栈切换的进程切换"></a>实验：基于内核栈切换的进程切换</h2><p>环境：linux0.11</p><p>Linux0.11完成进程切换是依靠任务状态段（task state segment, TSS)的切换来完成的。</p><p>现在我们要舍弃TSS，重新写一个切换程序。</p><p>关于TSS具体的过程参考该<a href="https://www.lanqiao.cn/courses/115/learning/?id=571"><strong>链接</strong></a></p><p>有一个任务寄存器（Task Register，简称 TR）指向当前进程对应的 TSS 结构体，所谓的 TSS 切换就将 CPU 中几乎所有的寄存器都复制到 TR 指向的那个 TSS 结构体中保存起来，同时找到一个目标 TSS，即要切换到的下一个进程对应的 TSS，将其中存放的寄存器映像“扣在” CPU 上，就完成了执行现场的切换。</p><p>虽然用一条指令就能完成任务切换，但这指令的执行时间却很长，这条 ljmp 指令在实现任务切换时大概需要 200 多个时钟周期（TSS）。而通过堆栈实现任务切换可能要更快，而且采用堆栈的切换还可以使用指令流水的并行优化技术，同时又使得 CPU 的设计变得简单</p><p>进程的切换：PCB和内存映射表都要切换</p><p>原始的切换位置的程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * &#x27;schedule()&#x27;是调度函数。这是个很好的代码！没有任何理由对它进行修改，因为它可以在所有的</span><br><span class="hljs-comment"> * 环境下工作（比如能够对IO-边界处理很好的响应等）。只有一件事值得留意，那就是这里的信号</span><br><span class="hljs-comment"> * 处理代码。</span><br><span class="hljs-comment"> * 注意！！任务0 是个闲置(&#x27;idle&#x27;)任务，只有当没有其它任务可以运行时才调用它。它不能被杀</span><br><span class="hljs-comment"> * 死，也不能睡眠。任务0 中的状态信息&#x27;state&#x27;是从来不用的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i, next, c;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> **<span class="hljs-title">p</span>;</span><span class="hljs-comment">// 任务结构指针的指针。</span><br><br><span class="hljs-comment">/* 检测alarm（进程的报警定时值），唤醒任何已得到信号的可中断任务 */</span><br><br><span class="hljs-comment">// 从任务数组中最后一个任务开始检测alarm。</span><br><span class="hljs-keyword">for</span> (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p)<br><span class="hljs-keyword">if</span> (*p)<br>&#123;<br><span class="hljs-comment">// 如果任务的alarm 时间已经过期(alarm&lt;jiffies),则在信号位图中置SIGALRM 信号，然后清alarm。</span><br><span class="hljs-comment">// jiffies 是系统从开机开始算起的滴答数（10ms/滴答）。定义在sched.h 第139 行。</span><br><span class="hljs-keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies)<br>&#123;<br>(*p)-&gt;signal |= (<span class="hljs-number">1</span> &lt;&lt; (SIGALRM - <span class="hljs-number">1</span>));<br>(*p)-&gt;alarm = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 如果信号位图中除被阻塞的信号外还有其它信号，并且任务处于可中断状态，则置任务为就绪状态。</span><br><span class="hljs-comment">// 其中&#x27;~(_BLOCKABLE &amp; (*p)-&gt;blocked)&#x27;用于忽略被阻塞的信号，但SIGKILL 和SIGSTOP 不能被阻塞。</span><br><span class="hljs-keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;<br>(*p)-&gt;state == TASK_INTERRUPTIBLE)<br>(*p)-&gt;state = TASK_RUNNING;<span class="hljs-comment">//置为就绪（可执行）状态。</span><br>&#125;<br><br>  <span class="hljs-comment">/* 这里是调度程序的主要部分 */</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>c = <span class="hljs-number">-1</span>;<br>next = <span class="hljs-number">0</span>;<br>i = NR_TASKS;<br>p = &amp;task[NR_TASKS];<br><span class="hljs-comment">// 这段代码也是从任务数组的最后一个任务开始循环处理，并跳过不含任务的数组槽。比较每个就绪</span><br><span class="hljs-comment">// 状态任务的counter（任务运行时间的递减滴答计数）值，哪一个值大，运行时间还不长，next 就</span><br><span class="hljs-comment">// 指向哪个的任务号。</span><br><span class="hljs-keyword">while</span> (--i)<br>&#123;<br><span class="hljs-keyword">if</span> (!*--p)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)<br>c = (*p)-&gt;counter, next = i;<br>&#125;<br>      <span class="hljs-comment">// 如果比较得出有counter 值大于0 的结果，则退出124 行开始的循环，执行任务切换（141 行）。</span><br><span class="hljs-keyword">if</span> (c)<br><span class="hljs-keyword">break</span>;<br>      <span class="hljs-comment">// 否则就根据每个任务的优先权值，更新每一个任务的counter 值，然后回到125 行重新比较。</span><br>      <span class="hljs-comment">// counter 值的计算方式为counter = counter /2 + priority。[右边counter=0??]</span><br><span class="hljs-keyword">for</span> (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p)<br><span class="hljs-keyword">if</span> (*p)<br>(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="hljs-number">1</span>) + (*p)-&gt;priority;<br>&#125;<br><span class="hljs-built_in">switch_to</span> (next);<span class="hljs-comment">// 切换到任务号为next 的任务，并运行之。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>switch_to()为切换函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//TSS切换函数如下</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> switch_to(n) &#123;\</span><br><span class="hljs-meta">struct &#123;long a,b;&#125; __tmp; \</span><br><span class="hljs-meta">__asm__( <span class="hljs-meta-string">&quot;cmpl %%ecx,_current\n\t&quot;</span> \</span><br>  <span class="hljs-string">&quot;je 1f\n\t&quot;</span> \<br>  <span class="hljs-string">&quot;movw %%dx,%1\n\t&quot;</span> \<br>  <span class="hljs-string">&quot;xchgl %%ecx,_current\n\t&quot;</span> \。<br>  <span class="hljs-string">&quot;ljmp %0\n\t&quot;</span> \。<br><span class="hljs-comment">// 在任务切换回来后才会继续执行下面的语句。</span><br>  <span class="hljs-string">&quot;cmpl %%ecx,_last_task_used_math\n\t&quot;</span> \<br>  <span class="hljs-string">&quot;jne 1f\n\t&quot;</span> \<br>  <span class="hljs-string">&quot;clts\n&quot;</span> \<br>  <span class="hljs-string">&quot;1:&quot;</span>::<span class="hljs-string">&quot;m&quot;</span> (*&amp;__tmp.a), <span class="hljs-string">&quot;m&quot;</span> (*&amp;__tmp.b),<br>  <span class="hljs-string">&quot;d&quot;</span> (_TSS (n)), <span class="hljs-string">&quot;c&quot;</span> ((<span class="hljs-keyword">long</span>) task[n]));<br>&#125;<br></code></pre></td></tr></table></figure><p>修改：我们需要一个指针指向我们要切换的地址，进程切换必然要涉及到 LDT 的切换。linux0.11是没有线程的。</p><p>每个进程对应有 1 个 TSS 和 1 个 LDT，LDT 就是个映射表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对应的修改为：</span><br><span class="hljs-keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)<br>&#123;<br><span class="hljs-comment">/* code */</span><br>c = (*p)-&gt;counter, next = i; pnext = *p;<br>&#125;<br><span class="hljs-comment">//当前的进程使用全局变量保存的，所以只需要下一个要切换的进程</span><br><span class="hljs-comment">//pnext 是任务结构指针，也就是堆栈</span><br><span class="hljs-built_in">switch_to</span>(pnext, _LDT(next));<br></code></pre></td></tr></table></figure><p>重新switch_to函数</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.align</span> 2 #对齐伪指令，必须从一个能被2整除的地址开始为下面的内存变量分配空间<br>switch_to:<br>#这一部分的解释，看上述内存模型: stack<br>pushl %ebp<br>movl %esp,%ebp<br>pushl %ecx<br>pushl %ebx<br>pushl %eax<br>movl <span class="hljs-number">8</span>(%ebp),%ebx # 调用switch_to的第一个参数，即pnext——目标进程的PCB<br>cmpl %ebx, current #和 current 做一个比较, current指向当前进程的PCB<br>je <span class="hljs-number">1</span>f   #相等就啥也不用做，跳转到“<span class="hljs-number">1</span>：”直接恢复保存的寄存器即可<br>#不相等，开始进程切换<br>#先切换PCB<br>movl %ebx,%eax #eax指向目标进程的PCB<br>xchgl %eax,current #current指向目标进程的PCB, eax指向当前进程的PCB<br><br>#TSS中的内核指针的重写<br>movl tss,%ecx #ecx指向当前进程的TSS<br>addl $<span class="hljs-number">4096</span>,%ebx #ebx指向的是目标进程的PCB，+<span class="hljs-number">4096</span>后指向目标进程的内核栈<br>movl %ebx,ESP0(%ecx) #TSS的esp0指向目标进程的内核栈<br><br>#切换内核栈栈顶指针（切换当前的内核栈为目标内核栈）；当然要先保存被切换进程的esp<br>movl %esp, KERNEL_STACK(%eax) #把当前进程的esp保存到其PCB中<br>movl <span class="hljs-number">8</span>(%ebp),%ebx #再一次把目标进程的PCB存储到ebx中<br>movl KERNEL_STACK(%ebx),%esp #把目标进程PCB中的内核栈基址存储到esp中<br><br>#切换LDT<br>movl <span class="hljs-number">12</span>(%ebp),%ecx #把_LDT(next)存储到ecx中<br>lldt %cx #修改LDTR寄存器后，目标进程在执行用户态程序时使用的映射表就是自己的LDT表，实现了地址空间的分离。<br><br>#通过ret完成PC的切换<br><br>#切换LDT之后，更新fs，指向目标进程的用户态内存<br>movl $<span class="hljs-number">0</span>x17,%ecx  #用户空间数据段选择符为<span class="hljs-number">0</span>x17<br>mov %cx,%fs <br><br>#和后面的clts配合来处理协处理器，由于和主题关系不大，此处不做论述<br>cmpl %eax, last_task_used_math<br>jne <span class="hljs-number">1</span>f<br>clts<br><span class="hljs-number">1</span>:<br>popl %eax<br>popl %ebx<br>popl %ecx<br>popl %ebp<br>ret<br></code></pre></td></tr></table></figure><p>由于现在的 Linux 0.11 的 PCB 定义中没有保存内核栈指针这个域，所以需要加上，而宏 <code>KERNEL_STACK</code> 就是你加的那个位置，当然将 kernelstack 域加在 task_struct。</p><p>在linux-0.11/include/linux/sched.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br><span class="hljs-comment">/* these are hardcoded - don&#x27;t touch */</span><br><span class="hljs-keyword">long</span> state;<span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="hljs-keyword">long</span> counter;<br><span class="hljs-keyword">long</span> priority;<br><span class="hljs-keyword">long</span> kernelstack;<br><span class="hljs-keyword">long</span> signal;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sigaction</span>[32];</span><br>.<br>.<br>.<br>&#125;<br></code></pre></td></tr></table></figure><p>修改了结构体，同时也要修改该结构体的初始化。位置要对应起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INIT_TASK \</span><br><span class="hljs-meta"><span class="hljs-comment">/* state etc */</span>&#123; 0,15,15,PAGE_SIZE+(long)&amp;init_task, \</span><br><span class="hljs-meta"><span class="hljs-comment">/* signals */</span>0,&#123;&#123;&#125;,&#125;,0, \</span><br><span class="hljs-meta"><span class="hljs-comment">/* ec,brk... */</span>0,0,0,0,0,0, \</span><br><span class="hljs-meta"><span class="hljs-comment">/* pid etc.. */</span>0,-1,0,0,0, \</span><br><span class="hljs-meta"><span class="hljs-comment">/* uid etc */</span>0,0,0,0,0,0, \</span><br><span class="hljs-meta"><span class="hljs-comment">/* alarm */</span>0,0,0,0,0,0, \</span><br><span class="hljs-meta"><span class="hljs-comment">/* math */</span>0, \  </span><br></code></pre></td></tr></table></figure><p>修改fork</p><p>就是要把进程的用户栈、用户程序和其内核栈通过压在内核栈中的 <code>SS:ESP</code>，<code>CS:IP</code> 关联在一起。</p><p>在 fork() 的核心实现 <code>copy_process</code> 中，<code>p = (struct task_struct *) get_free_page();</code>用来完成申请一页内存(大小4k)作为子进程的 PCB</p><p>而 p 指针加上页面大小就是子进程的内核栈位置，所以语句 <code>krnstack = (long *) (PAGE_SIZE + (long) p);</code> 就可以找到子进程的内核栈位置</p><p>接下来就是初始化krnstack</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">*(--krnstack) = ss &amp; <span class="hljs-number">0xffff</span>;<br>*(--krnstack) = esp;<br>*(--krnstack) = eflags;<br>*(--krnstack) = cs &amp; <span class="hljs-number">0xffff</span>;<br>*(--krnstack) = eip;<br></code></pre></td></tr></table></figure><p>完成了如下图的关联</p><p><img src="Untitled%205.png" alt="Untitled"></p><p>由于 fork() 这个叉子的含义就是要让父子进程共用同一个代码、数据和堆栈，现在虽然是使用内核栈完成任务切换，但 fork() 的基本含义不会发生变化。</p><p>内核切换完事，到子进程的内核栈开始工作，接下来做的四次弹栈以及 ret 处理使用的都是子进程内核栈中的东西，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span>: popl %eax<br>    popl %ebx<br>    popl %ecx<br>    popl %ebp<br>ret<br></code></pre></td></tr></table></figure><p><img src="Untitled%206.png" alt="Untitled"></p><p>为了顺利的完成这些弹栈工作，子进程的内核栈中应该有这些内容，所以需要对 krnstack 进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">*(--krnstack) = ebp;<br>*(--krnstack) = ecx;<br>*(--krnstack) = ebx;<br><span class="hljs-comment">// 这里的 0 最有意思。</span><br>*(--krnstack) = <span class="hljs-number">0</span>;<span class="hljs-comment">//eax</span><br></code></pre></td></tr></table></figure><p>现在到了 ret 指令了，这条指令要从内核栈中弹出一个 32 位数作为 EIP 跳去执行，所以需要弄一个函数地址（仍然是一段汇编程序，所以这个地址是这段汇编程序开始处的标号）并将其初始化到栈中</p><p>我们弄的一个名为 <code>first_return_from_kernel</code> 的汇编标号，然后可以用语句 <code>(--krnstack) = (long) first_return_from_kernel;</code> 将这个地址初始化到子进程的内核栈中，现在执行 ret 以后就会跳转到 <code>first_return_from_kernel</code> 去执行了。</p><p><code>first_return_from_kernel</code> 完成用户栈和用户代码的切换。依靠的核心指令就是 iret，切换之前需要回复一下执行现场</p><p><code>first_return_from_kernel</code> 的核心代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">popl %edx<br>popl %edi<br>popl %esi<br>pop %gs<br>pop %fs<br>pop %es<br>pop %ds<br>iret<br></code></pre></td></tr></table></figure><p>将存放在 PCB 中的内核栈指针修改到初始化完成时内核栈的栈顶</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;kernelstack = krnstack;<br></code></pre></td></tr></table></figure><p>问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//kernel/sched.c在schedule函数中</span><br><span class="hljs-comment">//下面这段代码能正常编译，但是无法正常运行</span><br><span class="hljs-keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)<br>c = (*p)-&gt;counter, next = i; pnext = *p;<br><br><span class="hljs-comment">//而这段代码这可以正常运行</span><br><span class="hljs-keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)<br>c = (*p)-&gt;counter, next = i, pnext=*p;    <span class="hljs-comment">/**/</span><br><span class="hljs-comment">//其实这两段代码都是相同，为什么有这种差异。</span><br><span class="hljs-comment">//我重新写一遍又都正常了，奇怪。</span><br><span class="hljs-comment">//就这个问题困扰了我很久还没有解决，只有重新写。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS</title>
    <link href="/2021/11/24/DNS/"/>
    <url>/2021/11/24/DNS/</url>
    
    <content type="html"><![CDATA[<p>在浏览器中往往输入的是服务器的域名，很少输入IP地址来访问域名。</p><p>IP地址人们往往很难记忆，对名称的记忆更容易。</p><p>这就存在域名与IP地址的映射了。</p><p>域名转化成IP地址的过程需要DNS服务器进行解析。</p><p>而在编码是常用<code>gethostbyname()</code>函数来解析</p><span id="more"></span><p>我们的计算机上有DNS客户端向DNS服务器发送服务请求</p><p>生成查询消息</p><p>向DNS服务器发送查询消息</p><p>交给UDP来传输到目标服务器</p><p>DNS服务器根据查询消息返回响应消息</p><p>DNS使用的是53端口</p><p>假设离主机最近的DNS服务器，主机查询的名字在该区域内部和在缓存中，那么本地DNS服务器就直接返回信息</p><p>DNS服务器有缓存功能，可以记住之前查询过的域名。一般存活时间为2天</p><p>一台DNS服务器不可能包含所有的信息。</p><p>一台DNS服务器可以管理多个域的信息</p><p>DNS服务器中的所有信息都是按照域名以分层次的结构来保存的。顶级域(TLD)服务器</p><p><img src="Untitled.png" alt="Untitled"></p><p>一个域名为<a href="http://www.example.com.该域名下可以分配子域,比如www.sub1.example.com/">www.example.com。该域名下可以分配子域，比如www.sub1.example.com</a>; <a href="http://www.sub2.example.com.但是需要www.example.com域同意./">www.sub2.example.com.但是需要www.example.com域同意。</a></p><p>当本地DNS服务器中没有时，就需要向根DNS服务器进行查询。查询方式有两种。</p><p>递归查询：向根服务器查询，让根服务器找到后在返回域名信息</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>迭代查询：向根服务器查询，根服务器则告诉你，你应该找谁，以此循环</p><p><img src="Untitled%202.png" alt="Untitled"></p>]]></content>
    
    
    
    <tags>
      
      <tag>应用层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程状态</title>
    <link href="/2021/11/23/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <url>/2021/11/23/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>进程的5种状态：创建，就绪，运行，阻塞，完成</p><p>在用户编写程序使用<code>fork()</code>函数可以创建子进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">pid_t</span> pid;<br>pid = fork();<br></code></pre></td></tr></table></figure><p><img src="%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="进程状态转移图"></p><span id="more"></span><p>用户是调用了内核中fork.c中的函数（linux-0.11/kernel/fork.c），其中主要copy_process()函数起作用（复制进程）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* OK，下面是主要的fork 子程序。它复制系统进程信息(task[n])并且设置必要的寄存器。</span><br><span class="hljs-comment">* 它还整个地复制数据段。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 复制进程。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">copy_process</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nr, <span class="hljs-keyword">long</span> ebp, <span class="hljs-keyword">long</span> edi, <span class="hljs-keyword">long</span> esi, <span class="hljs-keyword">long</span> gs, <span class="hljs-keyword">long</span> none,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">long</span> ebx, <span class="hljs-keyword">long</span> ecx, <span class="hljs-keyword">long</span> edx,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">long</span> fs, <span class="hljs-keyword">long</span> es, <span class="hljs-keyword">long</span> ds,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">long</span> eip, <span class="hljs-keyword">long</span> cs, <span class="hljs-keyword">long</span> eflags, <span class="hljs-keyword">long</span> esp, <span class="hljs-keyword">long</span> ss)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span>;</span><br><span class="hljs-keyword">int</span> i;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i387_struct</span> *<span class="hljs-title">p_i387</span>;</span><br><span class="hljs-comment">//**开始创建进程**</span><br>p = (struct task_struct *) <span class="hljs-built_in">get_free_page</span> ();<span class="hljs-comment">// 为新任务数据结构分配内存。</span><br><span class="hljs-keyword">if</span> (!p)<span class="hljs-comment">// 如果内存分配出错，则返回出错码并退出。</span><br><span class="hljs-keyword">return</span> -EAGAIN;<br>task[nr] = p;<span class="hljs-comment">// 将新任务结构指针放入任务数组中。</span><br><span class="hljs-comment">// 其中nr 为任务号，由前面find_empty_process()返回。</span><br>*p = *current;<span class="hljs-comment">/* NOTE! this doesn&#x27;t copy the supervisor stack */</span><br><span class="hljs-comment">/* 注意！这样做不会复制超级用户的堆栈 （只复制当前进程内容）。*/</span> <br>p-&gt;state = TASK_UNINTERRUPTIBLE;<span class="hljs-comment">// 将新进程的状态先置为不可中断等待状态。</span><br>p-&gt;pid = last_pid;<span class="hljs-comment">// 新进程号。由前面调用find_empty_process()得到。</span><br>p-&gt;father = current-&gt;pid;<span class="hljs-comment">// 设置父进程号。</span><br>p-&gt;counter = p-&gt;priority;<br>p-&gt;signal = <span class="hljs-number">0</span>;<span class="hljs-comment">// 信号位图置0。</span><br>p-&gt;alarm = <span class="hljs-number">0</span>;<br>p-&gt;leader = <span class="hljs-number">0</span>;<span class="hljs-comment">/* process leadership doesn&#x27;t inherit */</span><br><span class="hljs-comment">/* 进程的领导权是不能继承的 */</span><br>p-&gt;utime = p-&gt;stime = <span class="hljs-number">0</span>;<span class="hljs-comment">// 初始化用户态时间和核心态时间。</span><br>p-&gt;cutime = p-&gt;cstime = <span class="hljs-number">0</span>;<span class="hljs-comment">// 初始化子进程用户态和核心态时间。</span><br>p-&gt;start_time = jiffies;<span class="hljs-comment">// 当前滴答数时间。</span><br><span class="hljs-comment">// jiffies 表示从开机时到现在发生的时钟中断次数</span><br><span class="hljs-comment">// 以下设置任务状态段TSS 所需的数据（参见列表后说明）。</span><br>p-&gt;tss.back_link = <span class="hljs-number">0</span>;<br>p-&gt;tss.esp0 = PAGE_SIZE + (<span class="hljs-keyword">long</span>) p;<span class="hljs-comment">// 堆栈指针（由于是给任务结构p 分配了1 页</span><br><span class="hljs-comment">// 新内存，所以此时esp0 正好指向该页顶端）。</span><br>p-&gt;tss.ss0 = <span class="hljs-number">0x10</span>;<span class="hljs-comment">// 堆栈段选择符（内核数据段）[??]。</span><br>p-&gt;tss.eip = eip;<span class="hljs-comment">// 指令代码指针。</span><br>p-&gt;tss.eflags = eflags;<span class="hljs-comment">// 标志寄存器。</span><br>p-&gt;tss.eax = <span class="hljs-number">0</span>;<br>p-&gt;tss.ecx = ecx;<br>p-&gt;tss.edx = edx;<br>p-&gt;tss.ebx = ebx;<br>p-&gt;tss.esp = esp;<br>p-&gt;tss.ebp = ebp;<br>p-&gt;tss.esi = esi;<br>p-&gt;tss.edi = edi;<br>p-&gt;tss.es = es &amp; <span class="hljs-number">0xffff</span>;<span class="hljs-comment">// 段寄存器仅16 位有效。</span><br>p-&gt;tss.cs = cs &amp; <span class="hljs-number">0xffff</span>;<br>p-&gt;tss.ss = ss &amp; <span class="hljs-number">0xffff</span>;<br>p-&gt;tss.ds = ds &amp; <span class="hljs-number">0xffff</span>;<br>p-&gt;tss.fs = fs &amp; <span class="hljs-number">0xffff</span>;<br>p-&gt;tss.gs = gs &amp; <span class="hljs-number">0xffff</span>;<br>p-&gt;tss.ldt = _LDT (nr);<span class="hljs-comment">// 该新任务nr 的局部描述符表选择符（LDT 的描述符在GDT 中）。</span><br>p-&gt;tss.trace_bitmap = <span class="hljs-number">0x80000000</span>;<br><span class="hljs-comment">// 如果当前任务使用了协处理器，就保存其上下文。</span><br>p_i387 = &amp;p-&gt;tss.i387;<br><span class="hljs-keyword">if</span> (last_task_used_math == current)<br>_asm&#123;<br>mov ebx, p_i387<br>clts<br>fnsave [p_i387]<br>&#125;<br><span class="hljs-comment">//    __asm__ (&quot;clts ; fnsave %0&quot;::&quot;m&quot; (p-&gt;tss.i387));</span><br><span class="hljs-comment">// 设置新任务的代码和数据段基址、限长并复制页表。如果出错（返回值不是0），则复位任务数组中</span><br><span class="hljs-comment">// 相应项并释放为该新任务分配的内存页。</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_mem</span> (nr, p))<br>&#123;<span class="hljs-comment">// 返回不为0 表示出错。</span><br>task[nr] = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">free_page</span> ((<span class="hljs-keyword">long</span>) p);<br><span class="hljs-keyword">return</span> -EAGAIN;<br>&#125;<br><span class="hljs-comment">// 如果父进程中有文件是打开的，则将对应文件的打开次数增1。</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NR_OPEN; i++)<br><span class="hljs-keyword">if</span> (f = p-&gt;filp[i])<br>f-&gt;f_count++;<br><span class="hljs-comment">// 将当前进程（父进程）的pwd, root 和executable 引用次数均增1。</span><br><span class="hljs-keyword">if</span> (current-&gt;pwd)<br>current-&gt;pwd-&gt;i_count++;<br><span class="hljs-keyword">if</span> (current-&gt;root)<br>current-&gt;root-&gt;i_count++;<br><span class="hljs-keyword">if</span> (current-&gt;executable)<br>current-&gt;executable-&gt;i_count++;<br><span class="hljs-comment">// 在GDT 中设置新任务的TSS 和LDT 描述符项，数据从task 结构中取。</span><br><span class="hljs-comment">// 在任务切换时，任务寄存器tr 由CPU 自动加载。</span><br><span class="hljs-built_in">set_tss_desc</span> (gdt + (nr &lt;&lt; <span class="hljs-number">1</span>) + FIRST_TSS_ENTRY, &amp;(p-&gt;tss));<br><span class="hljs-built_in">set_ldt_desc</span> (gdt + (nr &lt;&lt; <span class="hljs-number">1</span>) + FIRST_LDT_ENTRY, &amp;(p-&gt;ldt));<br><span class="hljs-comment">//**进程创建完成，则程序进入到就绪态，等待运行**</span><br>p-&gt;state = TASK_RUNNING;<span class="hljs-comment">/* do this last, just in case */</span><br><span class="hljs-comment">/* 最后再将新任务设置成可运行状态，以防万一 */</span><br><span class="hljs-keyword">return</span> last_pid;<span class="hljs-comment">// 返回新进程号（与任务号是不同的）。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建  ——&gt;  就绪</p><p>现在进程在就绪队列中等待分配CPU资源运行。</p><p>当一个进程在CPU结束运行后如何在就绪队列中选择进程运行呢？</p><ol><li>根据等待的顺序来选择</li><li>根据优先级高低来选择</li><li>根据短任务优先（分配的时间片短）</li></ol><p>在Linux0.11中 linux-0.11/kernel/sched.c调度算法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * &#x27;schedule()&#x27;是调度函数。这是个很好的代码！没有任何理由对它进行修改，因为它可以在所有的</span><br><span class="hljs-comment"> * 环境下工作（比如能够对IO-边界处理很好的响应等）。只有一件事值得留意，那就是这里的信号</span><br><span class="hljs-comment"> * 处理代码。</span><br><span class="hljs-comment"> * 注意！！任务0 是个闲置(&#x27;idle&#x27;)任务，只有当没有其它任务可以运行时才调用它。它不能被杀</span><br><span class="hljs-comment"> * 死，也不能睡眠。任务0 中的状态信息&#x27;state&#x27;是从来不用的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i, next, c;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> **<span class="hljs-title">p</span>;</span><span class="hljs-comment">// 任务结构指针的指针。</span><br><br><span class="hljs-comment">/* 检测alarm（进程的报警定时值），唤醒任何已得到信号的可中断任务 */</span><br><br><span class="hljs-comment">// 从任务数组中最后一个任务开始检测alarm。</span><br><span class="hljs-keyword">for</span> (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p)<br><span class="hljs-keyword">if</span> (*p)<br>&#123;<br><span class="hljs-comment">// 如果任务的alarm 时间已经过期(alarm&lt;jiffies),则在信号位图中置SIGALRM 信号，然后清alarm。</span><br><span class="hljs-comment">// jiffies 是系统从开机开始算起的滴答数（10ms/滴答）。定义在sched.h 第139 行。</span><br><span class="hljs-keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies)<br>&#123;<br>(*p)-&gt;signal |= (<span class="hljs-number">1</span> &lt;&lt; (SIGALRM - <span class="hljs-number">1</span>));<br>(*p)-&gt;alarm = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 如果信号位图中除被阻塞的信号外还有其它信号，并且任务处于可中断状态，则置任务为就绪状态。</span><br><span class="hljs-comment">// 其中&#x27;~(_BLOCKABLE &amp; (*p)-&gt;blocked)&#x27;用于忽略被阻塞的信号，但SIGKILL 和SIGSTOP 不能被阻塞。</span><br><span class="hljs-keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;<br>(*p)-&gt;state == TASK_INTERRUPTIBLE)<br>(*p)-&gt;state = TASK_RUNNING;<span class="hljs-comment">//置为就绪（可执行）状态。</span><br>&#125;<br><br>  <span class="hljs-comment">/* 这里是调度程序的主要部分 */</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>c = <span class="hljs-number">-1</span>;<br>next = <span class="hljs-number">0</span>;<br>i = NR_TASKS;<span class="hljs-comment">//进程的数量 64</span><br>p = &amp;task[NR_TASKS];<br><span class="hljs-comment">// 这段代码也是从任务数组的最后一个任务开始循环处理，并跳过不含任务的数组槽。比较每个就绪</span><br><span class="hljs-comment">// 状态任务的counter（任务运行时间的递减滴答计数）值，哪一个值大，运行时间还不长，next 就</span><br><span class="hljs-comment">// 指向哪个的任务号。</span><br><span class="hljs-keyword">while</span> (--i)<br>&#123;<br><span class="hljs-keyword">if</span> (!*--p)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">//**counter是时间片也是优先等级，时间片越大优先级就越高</span><br><span class="hljs-comment">//找出counter最大的一个进程，最为下一个运行的程序**</span><br><span class="hljs-keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)<br>c = (*p)-&gt;counter, next = i;<br>&#125;<br>      <span class="hljs-comment">// 如果比较得出有counter 值大于0 的结果，则退出124 行开始的循环，执行任务切换（141 行）。</span><br><span class="hljs-keyword">if</span> (c)<br><span class="hljs-keyword">break</span>;<br>      <span class="hljs-comment">// 否则就根据每个任务的优先权值，更新每一个任务的counter 值，然后回到125 行重新比较。</span><br>      <span class="hljs-comment">// counter 值的计算方式为**counter = counter /2 + priority**。[右边counter=0??]</span><br><span class="hljs-comment">//**把所的进程更新时间片**</span><br><span class="hljs-keyword">for</span> (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p)<br><span class="hljs-keyword">if</span> (*p)<br>(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="hljs-number">1</span>) + (*p)-&gt;priority;<br>&#125;<br><span class="hljs-built_in">switch_to</span> (next);<span class="hljs-comment">// 切换到任务号为next 的任务，并运行之。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意到这里的counter和priority在Linux0.11设置为15，15的</p><p>就绪态  ——&gt;   运行态</p><p>当时间片使用完后，该进程还没有执行完需要再分配时间片。</p><p>也就是上述代码所示：目前的进程在与下一个进程切换，目前的进程只在时钟中断、int0x80中断和进程结束才会切换到下一个进程。而在<code>schedule()</code>函数中只涉及时间片，则判断当前进程的时间片使用完了。如果当前的进程还需要运行则把运行态  ——&gt;   就绪态，等待下一次的调用。而下一个进程从就绪态  ——&gt;   运行态。</p><p>一个进程除了在CPU在执行任务，也会读取磁盘上的信息，这个时候进程就会释放CPU的资源，让给其他的进程。这个时候该进程就阻塞了，相对与CPU来说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//// **pause()系统调用**。转换当前任务的状态为可中断的等待状态，并重新调度。</span><br><span class="hljs-comment">// 该系统调用将导致进程进入睡眠状态，直到收到一个信号。该信号用于终止进程或者使进程调用</span><br><span class="hljs-comment">// 一个信号捕获函数。只有当捕获了一个信号，并且信号捕获处理函数返回，pause()才会返回。</span><br><span class="hljs-comment">// 此时pause()返回值应该是-1，并且errno 被置为EINTR。这里还没有完全实现（直到0.95 版）。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_pause</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//把当前的进程的状态设置为阻塞态</span><br>current-&gt;state = TASK_INTERRUPTIBLE;<br><span class="hljs-keyword">if</span>(current-&gt;pid != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//fprintk(3,&quot;%d\tW\t%d\n&quot;,current-&gt;pid,jiffies);</span><br>&#125;<br><span class="hljs-comment">//切换进程使用CPU</span><br><span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个运行的进程可能发生不可中断睡眠状态和可中断睡眠状态时，会释放CPU资源，则进程状态：运行态 ——&gt; 阻塞态。之后调用shedule()函数把CPU资源给下一个进程使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 把当前任务置为不可中断的等待状态，并让睡眠队列头的指针指向当前任务。</span><br><span class="hljs-comment">// 只有明确地唤醒时才会返回。该函数提供了进程与中断处理程序之间的同步机制。</span><br><span class="hljs-comment">// sleep_on()自愿地放弃CPU的使用权</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep_on</span><span class="hljs-params">(struct task_struct **p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tmp</span>;</span><br><br><span class="hljs-keyword">if</span> (!p)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (current == &amp;(init_task.task))<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;task[0] trying to sleep&quot;</span>);<br>tmp = *p;<span class="hljs-comment">// 让tmp 指向已经在等待队列上的任务(如果有的话)</span><br>*p = current;<span class="hljs-comment">// 将睡眠队列头的等待指针指向当前任务。</span><br><span class="hljs-comment">//不可中断睡眠 (通常是在IO操作) 收到信号不唤醒和不可运行,</span><br><span class="hljs-comment">//不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。</span><br><span class="hljs-comment">//只有被使用wake_up()函数明确唤醒时才能转换到可运行的就绪状态**</span><br>current-&gt;state = TASK_UNINTERRUPTIBLE;<br><span class="hljs-comment">//fprintk(3,&quot;%d\tW\t%d\n&quot;,current-&gt;pid,jiffies);</span><br><span class="hljs-built_in">schedule</span>();<br> <span class="hljs-comment">// 唤醒队列中的上一个（tmp）睡眠进程。0 换作 TASK_RUNNING 更好</span><br><span class="hljs-comment">/* 依次唤醒，所以不可中断的睡眠进程一定是按严格从“队列”（一个依靠</span><br><span class="hljs-comment"> * 放在进程内核栈中的指针变量tmp维护的队列）的首部进行唤醒。而对于可</span><br><span class="hljs-comment"> * 中断的进程，除了用wake_up唤醒以外，也可以用信号（给进程发送一个信</span><br><span class="hljs-comment"> * 号，实际上就是将进程PCB中维护的一个向量的某一位置位，进程需要在合</span><br><span class="hljs-comment"> * 适的时候处理这一位。感兴趣的实验者可以阅读有关代码）来唤醒</span><br><span class="hljs-comment"> */</span>**<br><span class="hljs-keyword">if</span> (tmp) &#123;<br>tmp-&gt;state=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//fprintk(3,&quot;%d\tJ\t%d\n&quot;,tmp-&gt;pid,jiffies);</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 将当前任务置为可中断的等待状态，并放入*p 指定的等待队列中。参见列表后对sleep_on()的说明。</span><br><span class="hljs-comment">// **当进程处于可中断等待状态时，系统不会调度该进程执行。</span><br><span class="hljs-comment">// 当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，</span><br><span class="hljs-comment">// 都可以唤醒进程转换到就绪状态（运行状态）。**</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interruptible_sleep_on</span> <span class="hljs-params">(struct task_struct **p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tmp</span>;</span><br><br><span class="hljs-keyword">if</span> (!p)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (current == &amp;(init_task.task))<br><span class="hljs-built_in">panic</span> (<span class="hljs-string">&quot;task[0] trying to sleep&quot;</span>);<br>tmp = *p;<br>*p = current;<br>repeat:<br>current-&gt;state = TASK_INTERRUPTIBLE;<br><span class="hljs-built_in">schedule</span> ();<br><span class="hljs-comment">// 如果等待队列中还有等待任务，并且队列头指针所指向的任务不是当前任务时，则将该等待任务置为</span><br><span class="hljs-comment">// 可运行的就绪状态，并重新执行调度程序。当指针*p 所指向的不是当前任务时，表示在当前任务被放</span><br><span class="hljs-comment">// 入队列后，又有新的任务被插入等待队列中，因此，既然本任务是可中断的，就应该首先执行所有</span><br><span class="hljs-comment">// 其它的等待任务。</span><br><span class="hljs-keyword">if</span> (*p &amp;&amp; *p != current)<br>&#123;<br>(**p).state = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">goto</span> repeat;<br>&#125;<br><span class="hljs-comment">// 下面一句代码有误，应该是*p = tmp，让队列头指针指向其余等待任务，否则在当前任务之前插入</span><br><span class="hljs-comment">// 等待队列的任务均被抹掉了。参见图4.3。</span><br><span class="hljs-comment">// 唤醒队列中的上一个（tmp）睡眠进程。0 换作 TASK_RUNNING 更好**</span><br><span class="hljs-comment">// 在记录进程被唤醒时一定要考虑到这种情况，实验者一定要注意!!!</span><br>*p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (tmp)<br>tmp-&gt;state = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="%E6%8C%87%E9%92%88%E5%8F%98%E5%8C%96.png" alt="指针变化"></p><p>在阻塞态的进程等待除CPU资源外的资源，资源到了后需要唤醒进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 唤醒指定任务*p。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wake_up</span> <span class="hljs-params">(struct task_struct **p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (p &amp;&amp; *p)<br>&#123;<br>(**p).state = <span class="hljs-number">0</span>;<span class="hljs-comment">// 置为就绪（可运行）状态。</span><br>*p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时就把阻塞态 ——&gt; 就绪态</p><p>比如父进程等待子进程都结束后才开始运行，该父进程就存在调用系统等待</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_waitpid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> * stat_addr, <span class="hljs-keyword">int</span> options)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> flag, code;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> ** <span class="hljs-title">p</span>;</span><br><br><span class="hljs-built_in">verify_area</span>(stat_addr,<span class="hljs-number">4</span>);<br>repeat:<br>flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) &#123;<br><span class="hljs-keyword">if</span> (!*p || *p == current)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> ((*p)-&gt;father != current-&gt;pid)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> ((*p)-&gt;pid != pid)<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!pid) &#123;<br><span class="hljs-keyword">if</span> ((*p)-&gt;pgrp != current-&gt;pgrp)<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">if</span> ((*p)-&gt;pgrp != -pid)<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ((*p)-&gt;state) &#123;<br><span class="hljs-keyword">case</span> TASK_STOPPED:<br><span class="hljs-keyword">if</span> (!(options &amp; WUNTRACED))<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">put_fs_long</span>(<span class="hljs-number">0x7f</span>,stat_addr);<br><span class="hljs-keyword">return</span> (*p)-&gt;pid;<br><span class="hljs-keyword">case</span> TASK_ZOMBIE:<br>current-&gt;cutime += (*p)-&gt;utime;<br>current-&gt;cstime += (*p)-&gt;stime;<br>flag = (*p)-&gt;pid;<br>code = (*p)-&gt;exit_code;<br><span class="hljs-built_in">release</span>(*p);<br><span class="hljs-built_in">put_fs_long</span>(code,stat_addr);<br><span class="hljs-keyword">return</span> flag;<br><span class="hljs-keyword">default</span>:<br>flag=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag) &#123;<br><span class="hljs-keyword">if</span> (options &amp; WNOHANG)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//设置成可中断睡眠状态</span><br><span class="hljs-comment">// 父进程受到子进程执行完后的信号这就变成就绪态**</span><br>current-&gt;state=TASK_INTERRUPTIBLE;<br><span class="hljs-built_in">fprintk</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;%d\tW\t%d\n&quot;</span>,current-&gt;pid,jiffies);<br><span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">if</span> (!(current-&gt;signal &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;(SIGCHLD<span class="hljs-number">-1</span>))))<br><span class="hljs-keyword">goto</span> repeat;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> -EINTR;<br>&#125;<br><span class="hljs-keyword">return</span> -ECHILD;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行态 ——&gt; 结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_exit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> code)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i;<br><span class="hljs-built_in">free_page_tables</span>(<span class="hljs-built_in">get_base</span>(current-&gt;ldt[<span class="hljs-number">1</span>]),<span class="hljs-built_in">get_limit</span>(<span class="hljs-number">0x0f</span>));<br><span class="hljs-built_in">free_page_tables</span>(<span class="hljs-built_in">get_base</span>(current-&gt;ldt[<span class="hljs-number">2</span>]),<span class="hljs-built_in">get_limit</span>(<span class="hljs-number">0x17</span>));<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;NR_TASKS ; i++)<br><span class="hljs-keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;father == current-&gt;pid) &#123;<br>task[i]-&gt;father = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (task[i]-&gt;state == TASK_ZOMBIE)<br><span class="hljs-comment">/* assumption task[1] is always init */</span><br>(<span class="hljs-keyword">void</span>) <span class="hljs-built_in">send_sig</span>(SIGCHLD, task[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;NR_OPEN ; i++)<br><span class="hljs-keyword">if</span> (current-&gt;filp[i])<br><span class="hljs-built_in">sys_close</span>(i);<br><span class="hljs-built_in">iput</span>(current-&gt;pwd);<br>current-&gt;pwd=<span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">iput</span>(current-&gt;root);<br>current-&gt;root=<span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">iput</span>(current-&gt;executable);<br>current-&gt;executable=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty &gt;= <span class="hljs-number">0</span>)<br>tty_table[current-&gt;tty].pgrp = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (last_task_used_math == current)<br>last_task_used_math = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (current-&gt;leader)<br><span class="hljs-built_in">kill_session</span>();<br>**current-&gt;state = TASK_ZOMBIE;**<br><span class="hljs-built_in">fprintk</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;%d\tE\t%d\n&quot;</span>,current-&gt;pid,jiffies);<br>current-&gt;exit_code = code;<br><span class="hljs-built_in">tell_father</span>(current-&gt;father);<br><span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);<span class="hljs-comment">/* just to suppress warnings */</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP_Server</title>
    <link href="/2021/11/22/HTTP-Server/"/>
    <url>/2021/11/22/HTTP-Server/</url>
    
    <content type="html"><![CDATA[<p>Web服务器是基于HTTP实现的，而HTTP协议是运行在TCP之上的。所以在创建TCP连接这个过程是与C/S的过程是相似的。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//创建服务</span><br><span class="hljs-keyword">int</span> client_socket = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> server_socket = <span class="hljs-number">-1</span>;<br>    u_short port = <span class="hljs-number">8080</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_name</span>;</span><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(client_socket);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_name</span>;</span><br>    <span class="hljs-keyword">pthread_t</span> newthread;<br>    <br>    <span class="hljs-comment">//PF_INET</span><br>    <span class="hljs-keyword">if</span>((server_socket = <span class="hljs-built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(&amp;server_name,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(server_name));<br>    server_name.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    server_name.sin_family = AF_INET;<br>    server_name.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">bind</span>(server_socket, (struct sockaddr*)&amp;server_name, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(server_name)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">listen</span>(server_socket,<span class="hljs-number">5</span>)) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>client_socket = <span class="hljs-built_in">accept</span>(server_socket, (struct sockaddr*)&amp;client_name, <br>(<span class="hljs-keyword">socklen_t</span>*)&amp;len);<br></code></pre></td></tr></table></figure><p>Web接收到的信息是去掉TCP的头部，但是还有HTTP的头部。Web则是根据该头部的信息进行逻辑控制。一个Web服务器支持多个客户端，不同的套接字可以使用相同的端口号。</p><p>需要自己去解析HTTP的头部，来判断接下来服务器的动作。</p><p>根据HTTP头部的格式，我们一行行的读取信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 读取套接字的一行，把回车换行等情况都统一为换行符结束。</span><br><span class="hljs-comment">// 把读取到的信息存储到buf指针中</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_line</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sock, <span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span>((i &lt; size - <span class="hljs-number">1</span>) &amp;&amp; (c != <span class="hljs-string">&#x27;\n&#x27;</span>)) &#123;<br>        n = <span class="hljs-built_in">recv</span>(sock, &amp;c, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\r&#x27;</span>) &#123;<br>                <span class="hljs-comment">//MSG_PEEK时代表只是查看数据，而不取走数据</span><br>                n = <span class="hljs-built_in">recv</span>(sock, &amp;c, <span class="hljs-number">1</span>, MSG_PEEK);<br>                <span class="hljs-keyword">if</span>((n &gt; <span class="hljs-number">0</span>) &amp;&amp; (c==<span class="hljs-string">&#x27;\n&#x27;</span>))<br>                    <span class="hljs-built_in">recv</span>(sock,&amp;c,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">else</span><br>                    c = <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            &#125;<br>            buf[i] = c;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            c = <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf : %s\n&quot;</span>,buf);<br>    <span class="hljs-keyword">return</span> (i);<br>&#125;<br></code></pre></td></tr></table></figure><p>读取到信息后，需要判断请求的方法为POST还是GET，HTTP的版本，请求的文件是否存在等。</p><p>如果进行顺利，我们需要向客户端发送响应同时发送请求的信息。</p><p>通过HTTP的GET的方法，将输入的数据作为参数添加在URI后面发送给服务器。而POST则将数据放在HTTP请求消息的消息体中发送给服务器。</p><p>HTTP/1.0使用非持久连接</p><p>HTTP/1.1使用持久连接</p><p>非持久连接：Web服务器在发送一个对象资源就要使用一个TCP连接。最多只有一个对象在TCP连接上发送。下载多个对象需要多个TCP连接。</p><p>持久连接:多个对象可以在一个TCP连接上传输</p><p>比如：</p><p>当请求的默认网页中含有图片等对象，这是默认网页就不只有一个对象了。非持久连接则会发生多次的HTTP连接的过程，也就每个对象都花费一个RTT（往返时间）。持久连接一次请求完所有对象（客户端遇到一个引用对象就立即产生一个请求），所有的引用可能花费一个RTT。引用是在网页中的。</p><p>200 OK ： 请求成功，请求对象包含在响应报文的后续部分<br>301 Moved Permanently ：请求的对象已经被永久转移了；新的URL在响应报文的Location:<br>首部行中指定；客户端软件自动用新的URL去获取对象<br>400 Bad Request： 一个通用的差错代码，表示该请求不能被服务器解读<br>404 Not Found ： 请求的文档在该服务上没有找到<br>505 HTTP Version Not Supported</p><p>上述的Web服务器是无法支持维护用户的状态的。比如我们平常的网络购物，购物车，历史记录等。则使用一个Cookies来维护状态。</p><p>HTTP的请求报文和响应报文中都有一个cookies的首行</p><p>用户端系统中保存有一个cookies文件，有用户浏览器管理</p><p>在Web站点有一个后端数据库</p><p>cookies的运行过程</p><p><img src="Untitled.png" alt="Untitled"></p><p>Web缓存</p><p>如果每个客户端都访问一个Web服务器，那么他的载荷太大，容易崩溃的。怎样不访问原始服务器，就满足客户的请求。就出现了Web缓存。</p><p>好处：</p><p>降低客户端的请求响应时间</p><p>减少一个机构内部网络与Internet接入链路上的流量</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>客户端请求的对象在缓存器中不是最新的，则转向原Web服务器。原Web服务器把对象发送给客户端，同时更新缓存器中的对象。是通过HTTP头部中last-modified字段来判断的</p><p>缓存器</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>应用层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP_Socket</title>
    <link href="/2021/11/22/TCP-Socket/"/>
    <url>/2021/11/22/TCP-Socket/</url>
    
    <content type="html"><![CDATA[<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><blockquote><p>这里的进程通信是基于网络的通信</p></blockquote><p>进程</p><p><img src="Untitled.png" alt="Untitled"></p><p>进程可以在终端中查看到进程的基本属性。其中在网络通信中最重要的是<code>PID</code>（进程ID，也就是端口号），这样可以在主机上唯一的表示进程。</p><p>在同台主机上，不同的进程可以通过共享内存、管道、信号量和消息队列等。但是在不同的主机下只有通过网络（socket）进行通信。这里我们假设网络通道已经建立好，现在我们只需要使用就可以了。</p><p>现在有一个问题：一台主机如何找到我要交流的主机呢？</p><p>这里就引出了IP这个概念。每一个主机都有一个唯一的IP地址，就像你的家都有一个唯一的地址一样。当你想要与目的主机交流时，就需要提前知道对方的IP地址及<code>PID</code>。</p><p>网络提供了什么样的服务。（这里的网络指的是传输层及以下的）</p><p>我们可以使用socket进行网络编码。socket又分为：TCP socket，UDP socket 和Raw socket。我们主要使用TCP和UDP套接字。</p><span id="more"></span><p>现在我们来整理一下：</p><p>一台主机有许多的进程，我们使用PID来区分这些进程。同时进程也使用PID来找到要进行通信的进程。而不同主机则是使用IP进行标识，主机通信与上述的PID的相似。</p><p>现在可以知道一个进程进行网络通信，需要知道对方的主机IP和进程的PID。这和我们信封通信很相似。注意：你在与对方通信时也要说明，你的IP和PID，这样对方才能给你返信阿。</p><p>而我们通信的方式（也就是运输的方式）主要有三种， 每种方式要准备的东西是不同的（汽车，火车、飞机）。</p><p>现在对网络的通信应该有大致的了解吧。</p><h2 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h2><p>还是以信封通信为例。</p><p>经常通信的两人并且他们的地址不会发生改变。你不会觉得每次填写地址等信息感到效率低嘛？</p><p>这就提出了套接字这个概念，大致就是使用一个整数来表示对方和自己的地址等信息，再之后的通信只需要提交一个整数就可以了。也就是你常去邮局给我寄信，邮局的人每次都知道。久而久之，你来邮局就不用再填写那些地址信息，邮局自动就帮你做了。</p><p>这个整数是一个具有本地意义的标示，对方是不可见的。你去到对方的邮局当然没这种效果了阿！        </p><p>对于TCP套接字这个整数表示：<code>(源IP，源port，目标IP，目标port)</code>。不必在每个报文的发送都要指定这4元组。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>创建TCP套接字</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> serverSocket,connectSocket;<br><span class="hljs-comment">//如果不是TCP套接字，则socket中的参数需要修改</span><br><span class="hljs-keyword">if</span>((serverSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM,<span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>初始化主机状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>u_short port = <span class="hljs-number">2344</span>;<br><span class="hljs-built_in">memset</span>((<span class="hljs-keyword">char</span>*)&amp;server_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(server_addr));<br><span class="hljs-comment">//INADDR_ANY就是指定地址为0.0.0.0的地址，这个地址事实上表示不确定地址，</span><br><span class="hljs-comment">//或“所有地址”、“任意地址”。</span><br>server_addr.sin_addr.s_addr = INADDR_ANY;<br><span class="hljs-comment">//协议--ipv4</span><br>server_addr.sin_family = AF_INET;<br><span class="hljs-comment">//端口</span><br>server_addr.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br></code></pre></td></tr></table></figure><p>指定端口号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">bind</span>(serverSocket,(struct sockaddr *)&amp;server_addr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(server_addr)) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>监听，最大连接数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">listen</span>(serverSocket, <span class="hljs-number">5</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>等待连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> serverSocket,connectSocket;<br>connectSocket = <span class="hljs-built_in">accept</span>(serverSocket, (struct sockaddr*)&amp;client_addr, <br>(<span class="hljs-keyword">socklen_t</span> *)&amp;addr_len);<br></code></pre></td></tr></table></figure><p>现在双方连接以及建立，就可以开始通信了。<code>recv</code>接收信息，<code>send</code>发送信息</p><p><img src="Untitled1.png" alt="Untitled"></p><p>9999则对应connectSocket</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>创建套接字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> clientSocket;<br><span class="hljs-keyword">if</span>((clientSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>初始化连接对象状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>server_addr.sin_family = AF_INET;<br>server_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">2344</span>);<br>server_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br></code></pre></td></tr></table></figure><p>客户端在编程是不需要绑定端口，OS会自动绑定的。</p><p>连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">connect</span>(clientSocket, (struct sockaddr *)&amp;server_addr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(server_addr)) &lt; <span class="hljs-number">0</span>)<br> &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;connect&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>开始信息交流</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>应用层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo blog</title>
    <link href="/2021/11/17/hexo-blog/"/>
    <url>/2021/11/17/hexo-blog/</url>
    
    <content type="html"><![CDATA[<p>安装环境：Ubuntu</p><span id="more"></span><h2 id="安装nodejs-and-npm"><a href="#安装nodejs-and-npm" class="headerlink" title="安装nodejs and npm"></a>安装nodejs and npm</h2><figure class="highlight jsx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//先升级安装工具</span><br>sudo apt-get update<br>sudo apt-get upgrade<br><br><span class="hljs-comment">//安装</span><br>sudo apt-get install nodejs-legacy nodejs<br><span class="hljs-comment">//或者</span><br>sudo apt-get install node<br><br>sudo apt-get install npm<br></code></pre></td></tr></table></figure><p>当遇到版本低时</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//node有一个模块叫n，是专门用来管理node.js的版本。</span><br>npm install -g n<br><span class="hljs-comment">//升级node.js到最新稳定版</span><br>n stable<br><span class="hljs-comment">//n后面也可以跟随版本号</span><br></code></pre></td></tr></table></figure><p>查看安装是否成功</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">node -v<br>npm -v<br></code></pre></td></tr></table></figure><h2 id="现在安装hexo"><a href="#现在安装hexo" class="headerlink" title="现在安装hexo"></a>现在安装hexo</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">npm i hexo-cli -g<br><span class="hljs-comment">//验证是否成功</span><br>hexo -v<br></code></pre></td></tr></table></figure><h2 id="建立blog"><a href="#建立blog" class="headerlink" title="建立blog"></a>建立blog</h2><p>创建一个blog目录（<code>mkdir blogName</code>），使用<code>hexo init</code>初始化文件夹，接着<code>npm install</code>安装必备的组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">hexo g <span class="hljs-comment">//生成静态网页</span><br>hexo s <span class="hljs-comment">//启动本地服务</span><br>hexo d <span class="hljs-comment">//上传，目前还没有配置好，无法使用</span><br></code></pre></td></tr></table></figure><p>目前应该能启动一个简单的页面了</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>在blog目录下的themes文件夹下放置你自己的主题。</p><p>同时需要修改blog目录下的_config.yml中<code>theme：name</code>字段，name为你主题的文件夹名</p><p>主题：git clone –depth=1 <a href="https://github.com/JoeyBling/hexo-theme-yilia-plus.git">https://github.com/JoeyBling/hexo-theme-yilia-plus.git</a> ./yilia-plus</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">sudo apt-get install git<br></code></pre></td></tr></table></figure><p>链接github</p><p>ssh-keygen -t rsa -C “GitHub注册邮箱”，然后按提示输入</p><p>cat  ~/.ssh/id_rsa_pub下面的密钥复制到自己的GitHub上</p><p>同时配置_config.yml</p><p><img src="hexo.png" alt="Untitled"></p><p>yilia-plus</p><p>出现样式乱码，尝试使用：npm i hexo-generator-json-content –save</p>]]></content>
    
    
    
    <tags>
      
      <tag>安装教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
